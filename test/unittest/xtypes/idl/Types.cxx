// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file Types.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "Types.h"
#include "TypesTypeObject.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

#define SimpleUnionStruct_max_cdr_typesize 16ULL;
#define SequenceSequenceBoundsStruct_max_cdr_typesize 128ULL;

#define MyAliasEnumStruct_max_cdr_typesize 8ULL;
#define ArrayBadStruct_max_cdr_typesize 6ULL;
#define MapBadKeyStruct_max_cdr_typesize 24ULL;
#define SimpleBadUnionStruct_max_cdr_typesize 16ULL;
#define MyEnumStruct_max_cdr_typesize 8ULL;

#define ArrayStructEqual_max_cdr_typesize 12ULL;
#define LargeWStringStruct_max_cdr_typesize 167708ULL;

#define WStringStruct_max_cdr_typesize 1028ULL;
#define SequenceStruct_max_cdr_typesize 16ULL;
#define SimpleTypeUnionStruct_max_cdr_typesize 16ULL;

#define ArrayDimensionsStruct_max_cdr_typesize 20ULL;
#define SequenceSequenceStruct_max_cdr_typesize 44ULL;
#define MapBoundsStruct_max_cdr_typesize 40ULL;
#define SequenceStructEqual_max_cdr_typesize 16ULL;
#define MapStructEqual_max_cdr_typesize 24ULL;
#define BasicStruct_max_cdr_typesize 272ULL;
#define SequenceBoundsStruct_max_cdr_typesize 24ULL;
#define MapMapStruct_max_cdr_typesize 56ULL;
#define BasicWideStruct_max_cdr_typesize 536ULL;

#define SimplBadDiscUnionStruct_max_cdr_typesize 16ULL;
#define MapStruct_max_cdr_typesize 24ULL;

#define MyBadEnumStruct_max_cdr_typesize 8ULL;
#define SequenceBadStruct_max_cdr_typesize 10ULL;
#define SimpleUnionNamesStruct_max_cdr_typesize 16ULL;
#define LargeStringStruct_max_cdr_typesize 41934ULL;
#define ArrayStruct_max_cdr_typesize 12ULL;
#define BadBasicWideStruct_max_cdr_typesize 536ULL;
#define ArraySizeStruct_max_cdr_typesize 24ULL;

#define MapBadElemStruct_max_cdr_typesize 40ULL;
#define SimpleUnionStructEqual_max_cdr_typesize 16ULL;
#define BasicBadStruct_max_cdr_typesize 272ULL;
#define BasicNamesStruct_max_cdr_typesize 272ULL;
#define StringStruct_max_cdr_typesize 264ULL;

#define MapMapBoundsStruct_max_cdr_typesize 104ULL;
#define SimpleUnionStruct_max_key_cdr_typesize 0ULL;
#define SequenceSequenceBoundsStruct_max_key_cdr_typesize 0ULL;

#define MyAliasEnumStruct_max_key_cdr_typesize 0ULL;
#define ArrayBadStruct_max_key_cdr_typesize 0ULL;
#define MapBadKeyStruct_max_key_cdr_typesize 0ULL;
#define SimpleBadUnionStruct_max_key_cdr_typesize 0ULL;
#define MyEnumStruct_max_key_cdr_typesize 0ULL;

#define ArrayStructEqual_max_key_cdr_typesize 0ULL;
#define LargeWStringStruct_max_key_cdr_typesize 0ULL;

#define WStringStruct_max_key_cdr_typesize 0ULL;
#define SequenceStruct_max_key_cdr_typesize 0ULL;
#define SimpleTypeUnionStruct_max_key_cdr_typesize 0ULL;

#define ArrayDimensionsStruct_max_key_cdr_typesize 0ULL;
#define SequenceSequenceStruct_max_key_cdr_typesize 0ULL;
#define MapBoundsStruct_max_key_cdr_typesize 0ULL;
#define SequenceStructEqual_max_key_cdr_typesize 0ULL;
#define MapStructEqual_max_key_cdr_typesize 0ULL;
#define BasicStruct_max_key_cdr_typesize 0ULL;
#define SequenceBoundsStruct_max_key_cdr_typesize 0ULL;
#define MapMapStruct_max_key_cdr_typesize 0ULL;
#define BasicWideStruct_max_key_cdr_typesize 0ULL;

#define SimplBadDiscUnionStruct_max_key_cdr_typesize 0ULL;
#define MapStruct_max_key_cdr_typesize 0ULL;

#define MyBadEnumStruct_max_key_cdr_typesize 0ULL;
#define SequenceBadStruct_max_key_cdr_typesize 0ULL;
#define SimpleUnionNamesStruct_max_key_cdr_typesize 0ULL;
#define LargeStringStruct_max_key_cdr_typesize 0ULL;
#define ArrayStruct_max_key_cdr_typesize 0ULL;
#define BadBasicWideStruct_max_key_cdr_typesize 0ULL;
#define ArraySizeStruct_max_key_cdr_typesize 0ULL;

#define MapBadElemStruct_max_key_cdr_typesize 0ULL;
#define SimpleUnionStructEqual_max_key_cdr_typesize 0ULL;
#define BasicBadStruct_max_key_cdr_typesize 0ULL;
#define BasicNamesStruct_max_key_cdr_typesize 0ULL;
#define StringStruct_max_key_cdr_typesize 0ULL;

#define MapMapBoundsStruct_max_key_cdr_typesize 0ULL;



MyEnumStruct::MyEnumStruct()
{

    // Just to register all known types
    registerTypesTypes();
}

MyEnumStruct::~MyEnumStruct()
{
}

MyEnumStruct::MyEnumStruct(
        const MyEnumStruct& x)
{
    m_my_enum = x.m_my_enum;
}

MyEnumStruct::MyEnumStruct(
        MyEnumStruct&& x) noexcept 
{
    m_my_enum = x.m_my_enum;
}

MyEnumStruct& MyEnumStruct::operator =(
        const MyEnumStruct& x)
{

    m_my_enum = x.m_my_enum;

    return *this;
}

MyEnumStruct& MyEnumStruct::operator =(
        MyEnumStruct&& x) noexcept
{

    m_my_enum = x.m_my_enum;

    return *this;
}

bool MyEnumStruct::operator ==(
        const MyEnumStruct& x) const
{

    return (m_my_enum == x.m_my_enum);
}

bool MyEnumStruct::operator !=(
        const MyEnumStruct& x) const
{
    return !(*this == x);
}

size_t MyEnumStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return MyEnumStruct_max_cdr_typesize;
}

size_t MyEnumStruct::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MyEnumStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_enum, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void MyEnumStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_enum;

    scdr.end_serialize_type(current_state);
}

void MyEnumStruct::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m_my_enum;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function sets a value in member my_enum
 * @param _my_enum New value for member my_enum
 */
void MyEnumStruct::my_enum(
        MyEnum _my_enum)
{
    m_my_enum = _my_enum;
}

/*!
 * @brief This function returns the value of member my_enum
 * @return Value of member my_enum
 */
MyEnum MyEnumStruct::my_enum() const
{
    return m_my_enum;
}

/*!
 * @brief This function returns a reference to member my_enum
 * @return Reference to member my_enum
 */
MyEnum& MyEnumStruct::my_enum()
{
    return m_my_enum;
}


size_t MyEnumStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return MyEnumStruct_max_key_cdr_typesize;
}

bool MyEnumStruct::isKeyDefined()
{
    return false;
}

void MyEnumStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

MyBadEnumStruct::MyBadEnumStruct()
{

    // Just to register all known types
    registerTypesTypes();
}

MyBadEnumStruct::~MyBadEnumStruct()
{
}

MyBadEnumStruct::MyBadEnumStruct(
        const MyBadEnumStruct& x)
{
    m_my_enum = x.m_my_enum;
}

MyBadEnumStruct::MyBadEnumStruct(
        MyBadEnumStruct&& x) noexcept 
{
    m_my_enum = x.m_my_enum;
}

MyBadEnumStruct& MyBadEnumStruct::operator =(
        const MyBadEnumStruct& x)
{

    m_my_enum = x.m_my_enum;

    return *this;
}

MyBadEnumStruct& MyBadEnumStruct::operator =(
        MyBadEnumStruct&& x) noexcept
{

    m_my_enum = x.m_my_enum;

    return *this;
}

bool MyBadEnumStruct::operator ==(
        const MyBadEnumStruct& x) const
{

    return (m_my_enum == x.m_my_enum);
}

bool MyBadEnumStruct::operator !=(
        const MyBadEnumStruct& x) const
{
    return !(*this == x);
}

size_t MyBadEnumStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return MyBadEnumStruct_max_cdr_typesize;
}

size_t MyBadEnumStruct::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MyBadEnumStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_enum, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void MyBadEnumStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_enum;

    scdr.end_serialize_type(current_state);
}

void MyBadEnumStruct::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m_my_enum;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function sets a value in member my_enum
 * @param _my_enum New value for member my_enum
 */
void MyBadEnumStruct::my_enum(
        MyBadEnum _my_enum)
{
    m_my_enum = _my_enum;
}

/*!
 * @brief This function returns the value of member my_enum
 * @return Value of member my_enum
 */
MyBadEnum MyBadEnumStruct::my_enum() const
{
    return m_my_enum;
}

/*!
 * @brief This function returns a reference to member my_enum
 * @return Reference to member my_enum
 */
MyBadEnum& MyBadEnumStruct::my_enum()
{
    return m_my_enum;
}


size_t MyBadEnumStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return MyBadEnumStruct_max_key_cdr_typesize;
}

bool MyBadEnumStruct::isKeyDefined()
{
    return false;
}

void MyBadEnumStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


MyAliasEnumStruct::MyAliasEnumStruct()
{

    // Just to register all known types
    registerTypesTypes();
}

MyAliasEnumStruct::~MyAliasEnumStruct()
{
}

MyAliasEnumStruct::MyAliasEnumStruct(
        const MyAliasEnumStruct& x)
{
    m_my_enum = x.m_my_enum;
}

MyAliasEnumStruct::MyAliasEnumStruct(
        MyAliasEnumStruct&& x) noexcept 
{
    m_my_enum = x.m_my_enum;
}

MyAliasEnumStruct& MyAliasEnumStruct::operator =(
        const MyAliasEnumStruct& x)
{

    m_my_enum = x.m_my_enum;

    return *this;
}

MyAliasEnumStruct& MyAliasEnumStruct::operator =(
        MyAliasEnumStruct&& x) noexcept
{

    m_my_enum = x.m_my_enum;

    return *this;
}

bool MyAliasEnumStruct::operator ==(
        const MyAliasEnumStruct& x) const
{

    return (m_my_enum == x.m_my_enum);
}

bool MyAliasEnumStruct::operator !=(
        const MyAliasEnumStruct& x) const
{
    return !(*this == x);
}

size_t MyAliasEnumStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return MyAliasEnumStruct_max_cdr_typesize;
}

size_t MyAliasEnumStruct::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MyAliasEnumStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_enum, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void MyAliasEnumStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_enum;

    scdr.end_serialize_type(current_state);
}

void MyAliasEnumStruct::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m_my_enum;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function sets a value in member my_enum
 * @param _my_enum New value for member my_enum
 */
void MyAliasEnumStruct::my_enum(
        MyAliasEnum _my_enum)
{
    m_my_enum = _my_enum;
}

/*!
 * @brief This function returns the value of member my_enum
 * @return Value of member my_enum
 */
MyAliasEnum MyAliasEnumStruct::my_enum() const
{
    return m_my_enum;
}

/*!
 * @brief This function returns a reference to member my_enum
 * @return Reference to member my_enum
 */
MyAliasEnum& MyAliasEnumStruct::my_enum()
{
    return m_my_enum;
}


size_t MyAliasEnumStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return MyAliasEnumStruct_max_key_cdr_typesize;
}

bool MyAliasEnumStruct::isKeyDefined()
{
    return false;
}

void MyAliasEnumStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

BasicStruct::BasicStruct()
{




    // Just to register all known types
    registerTypesTypes();
}

BasicStruct::~BasicStruct()
{



}

BasicStruct::BasicStruct(
        const BasicStruct& x)
{
    m_my_bool = x.m_my_bool;
    m_my_int32 = x.m_my_int32;
    m_my_string = x.m_my_string;
}

BasicStruct::BasicStruct(
        BasicStruct&& x) noexcept 
{
    m_my_bool = x.m_my_bool;
    m_my_int32 = x.m_my_int32;
    m_my_string = std::move(x.m_my_string);
}

BasicStruct& BasicStruct::operator =(
        const BasicStruct& x)
{

    m_my_bool = x.m_my_bool;
    m_my_int32 = x.m_my_int32;
    m_my_string = x.m_my_string;

    return *this;
}

BasicStruct& BasicStruct::operator =(
        BasicStruct&& x) noexcept
{

    m_my_bool = x.m_my_bool;
    m_my_int32 = x.m_my_int32;
    m_my_string = std::move(x.m_my_string);

    return *this;
}

bool BasicStruct::operator ==(
        const BasicStruct& x) const
{

    return (m_my_bool == x.m_my_bool && m_my_int32 == x.m_my_int32 && m_my_string == x.m_my_string);
}

bool BasicStruct::operator !=(
        const BasicStruct& x) const
{
    return !(*this == x);
}

size_t BasicStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return BasicStruct_max_cdr_typesize;
}

size_t BasicStruct::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const BasicStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_bool, current_alignment);
                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1), data.m_my_int32, current_alignment);
                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2), data.m_my_string, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void BasicStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_bool;scdr << eprosima::fastcdr::MemberId(1) << m_my_int32;scdr << eprosima::fastcdr::MemberId(2) << m_my_string;

    scdr.end_serialize_type(current_state);
}

void BasicStruct::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                            dcdr >> m_my_bool;
                                            break;
                                        
                                        case 1:
                                            dcdr >> m_my_int32;
                                            break;
                                        
                    case 2:
                        dcdr >> m_my_string;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function sets a value in member my_bool
 * @param _my_bool New value for member my_bool
 */
void BasicStruct::my_bool(
        bool _my_bool)
{
    m_my_bool = _my_bool;
}

/*!
 * @brief This function returns the value of member my_bool
 * @return Value of member my_bool
 */
bool BasicStruct::my_bool() const
{
    return m_my_bool;
}

/*!
 * @brief This function returns a reference to member my_bool
 * @return Reference to member my_bool
 */
bool& BasicStruct::my_bool()
{
    return m_my_bool;
}

/*!
 * @brief This function sets a value in member my_int32
 * @param _my_int32 New value for member my_int32
 */
void BasicStruct::my_int32(
        int32_t _my_int32)
{
    m_my_int32 = _my_int32;
}

/*!
 * @brief This function returns the value of member my_int32
 * @return Value of member my_int32
 */
int32_t BasicStruct::my_int32() const
{
    return m_my_int32;
}

/*!
 * @brief This function returns a reference to member my_int32
 * @return Reference to member my_int32
 */
int32_t& BasicStruct::my_int32()
{
    return m_my_int32;
}

/*!
 * @brief This function copies the value in member my_string
 * @param _my_string New value to be copied in member my_string
 */
void BasicStruct::my_string(
        const std::string& _my_string)
{
    m_my_string = _my_string;
}

/*!
 * @brief This function moves the value in member my_string
 * @param _my_string New value to be moved in member my_string
 */
void BasicStruct::my_string(
        std::string&& _my_string)
{
    m_my_string = std::move(_my_string);
}

/*!
 * @brief This function returns a constant reference to member my_string
 * @return Constant reference to member my_string
 */
const std::string& BasicStruct::my_string() const
{
    return m_my_string;
}

/*!
 * @brief This function returns a reference to member my_string
 * @return Reference to member my_string
 */
std::string& BasicStruct::my_string()
{
    return m_my_string;
}


size_t BasicStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return BasicStruct_max_key_cdr_typesize;
}

bool BasicStruct::isKeyDefined()
{
    return false;
}

void BasicStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

BasicNamesStruct::BasicNamesStruct()
{




    // Just to register all known types
    registerTypesTypes();
}

BasicNamesStruct::~BasicNamesStruct()
{



}

BasicNamesStruct::BasicNamesStruct(
        const BasicNamesStruct& x)
{
    m_my_bool_name = x.m_my_bool_name;
    m_my_int32_name = x.m_my_int32_name;
    m_my_string_name = x.m_my_string_name;
}

BasicNamesStruct::BasicNamesStruct(
        BasicNamesStruct&& x) noexcept 
{
    m_my_bool_name = x.m_my_bool_name;
    m_my_int32_name = x.m_my_int32_name;
    m_my_string_name = std::move(x.m_my_string_name);
}

BasicNamesStruct& BasicNamesStruct::operator =(
        const BasicNamesStruct& x)
{

    m_my_bool_name = x.m_my_bool_name;
    m_my_int32_name = x.m_my_int32_name;
    m_my_string_name = x.m_my_string_name;

    return *this;
}

BasicNamesStruct& BasicNamesStruct::operator =(
        BasicNamesStruct&& x) noexcept
{

    m_my_bool_name = x.m_my_bool_name;
    m_my_int32_name = x.m_my_int32_name;
    m_my_string_name = std::move(x.m_my_string_name);

    return *this;
}

bool BasicNamesStruct::operator ==(
        const BasicNamesStruct& x) const
{

    return (m_my_bool_name == x.m_my_bool_name && m_my_int32_name == x.m_my_int32_name && m_my_string_name == x.m_my_string_name);
}

bool BasicNamesStruct::operator !=(
        const BasicNamesStruct& x) const
{
    return !(*this == x);
}

size_t BasicNamesStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return BasicNamesStruct_max_cdr_typesize;
}

size_t BasicNamesStruct::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const BasicNamesStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_bool_name, current_alignment);
                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1), data.m_my_int32_name, current_alignment);
                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2), data.m_my_string_name, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void BasicNamesStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_bool_name;scdr << eprosima::fastcdr::MemberId(1) << m_my_int32_name;scdr << eprosima::fastcdr::MemberId(2) << m_my_string_name;

    scdr.end_serialize_type(current_state);
}

void BasicNamesStruct::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                            dcdr >> m_my_bool_name;
                                            break;
                                        
                                        case 1:
                                            dcdr >> m_my_int32_name;
                                            break;
                                        
                    case 2:
                        dcdr >> m_my_string_name;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function sets a value in member my_bool_name
 * @param _my_bool_name New value for member my_bool_name
 */
void BasicNamesStruct::my_bool_name(
        bool _my_bool_name)
{
    m_my_bool_name = _my_bool_name;
}

/*!
 * @brief This function returns the value of member my_bool_name
 * @return Value of member my_bool_name
 */
bool BasicNamesStruct::my_bool_name() const
{
    return m_my_bool_name;
}

/*!
 * @brief This function returns a reference to member my_bool_name
 * @return Reference to member my_bool_name
 */
bool& BasicNamesStruct::my_bool_name()
{
    return m_my_bool_name;
}

/*!
 * @brief This function sets a value in member my_int32_name
 * @param _my_int32_name New value for member my_int32_name
 */
void BasicNamesStruct::my_int32_name(
        int32_t _my_int32_name)
{
    m_my_int32_name = _my_int32_name;
}

/*!
 * @brief This function returns the value of member my_int32_name
 * @return Value of member my_int32_name
 */
int32_t BasicNamesStruct::my_int32_name() const
{
    return m_my_int32_name;
}

/*!
 * @brief This function returns a reference to member my_int32_name
 * @return Reference to member my_int32_name
 */
int32_t& BasicNamesStruct::my_int32_name()
{
    return m_my_int32_name;
}

/*!
 * @brief This function copies the value in member my_string_name
 * @param _my_string_name New value to be copied in member my_string_name
 */
void BasicNamesStruct::my_string_name(
        const std::string& _my_string_name)
{
    m_my_string_name = _my_string_name;
}

/*!
 * @brief This function moves the value in member my_string_name
 * @param _my_string_name New value to be moved in member my_string_name
 */
void BasicNamesStruct::my_string_name(
        std::string&& _my_string_name)
{
    m_my_string_name = std::move(_my_string_name);
}

/*!
 * @brief This function returns a constant reference to member my_string_name
 * @return Constant reference to member my_string_name
 */
const std::string& BasicNamesStruct::my_string_name() const
{
    return m_my_string_name;
}

/*!
 * @brief This function returns a reference to member my_string_name
 * @return Reference to member my_string_name
 */
std::string& BasicNamesStruct::my_string_name()
{
    return m_my_string_name;
}


size_t BasicNamesStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return BasicNamesStruct_max_key_cdr_typesize;
}

bool BasicNamesStruct::isKeyDefined()
{
    return false;
}

void BasicNamesStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

BasicBadStruct::BasicBadStruct()
{




    // Just to register all known types
    registerTypesTypes();
}

BasicBadStruct::~BasicBadStruct()
{



}

BasicBadStruct::BasicBadStruct(
        const BasicBadStruct& x)
{
    m_my_bool = x.m_my_bool;
    m_my_int32 = x.m_my_int32;
    m_my_string = x.m_my_string;
}

BasicBadStruct::BasicBadStruct(
        BasicBadStruct&& x) noexcept 
{
    m_my_bool = x.m_my_bool;
    m_my_int32 = x.m_my_int32;
    m_my_string = std::move(x.m_my_string);
}

BasicBadStruct& BasicBadStruct::operator =(
        const BasicBadStruct& x)
{

    m_my_bool = x.m_my_bool;
    m_my_int32 = x.m_my_int32;
    m_my_string = x.m_my_string;

    return *this;
}

BasicBadStruct& BasicBadStruct::operator =(
        BasicBadStruct&& x) noexcept
{

    m_my_bool = x.m_my_bool;
    m_my_int32 = x.m_my_int32;
    m_my_string = std::move(x.m_my_string);

    return *this;
}

bool BasicBadStruct::operator ==(
        const BasicBadStruct& x) const
{

    return (m_my_bool == x.m_my_bool && m_my_int32 == x.m_my_int32 && m_my_string == x.m_my_string);
}

bool BasicBadStruct::operator !=(
        const BasicBadStruct& x) const
{
    return !(*this == x);
}

size_t BasicBadStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return BasicBadStruct_max_cdr_typesize;
}

size_t BasicBadStruct::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const BasicBadStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_bool, current_alignment);
                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1), data.m_my_int32, current_alignment);
                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2), data.m_my_string, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void BasicBadStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_bool;scdr << eprosima::fastcdr::MemberId(1) << m_my_int32;scdr << eprosima::fastcdr::MemberId(2) << m_my_string;

    scdr.end_serialize_type(current_state);
}

void BasicBadStruct::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                            dcdr >> m_my_bool;
                                            break;
                                        
                                        case 1:
                                            dcdr >> m_my_int32;
                                            break;
                                        
                    case 2:
                        dcdr >> m_my_string;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function sets a value in member my_bool
 * @param _my_bool New value for member my_bool
 */
void BasicBadStruct::my_bool(
        uint8_t _my_bool)
{
    m_my_bool = _my_bool;
}

/*!
 * @brief This function returns the value of member my_bool
 * @return Value of member my_bool
 */
uint8_t BasicBadStruct::my_bool() const
{
    return m_my_bool;
}

/*!
 * @brief This function returns a reference to member my_bool
 * @return Reference to member my_bool
 */
uint8_t& BasicBadStruct::my_bool()
{
    return m_my_bool;
}

/*!
 * @brief This function sets a value in member my_int32
 * @param _my_int32 New value for member my_int32
 */
void BasicBadStruct::my_int32(
        int32_t _my_int32)
{
    m_my_int32 = _my_int32;
}

/*!
 * @brief This function returns the value of member my_int32
 * @return Value of member my_int32
 */
int32_t BasicBadStruct::my_int32() const
{
    return m_my_int32;
}

/*!
 * @brief This function returns a reference to member my_int32
 * @return Reference to member my_int32
 */
int32_t& BasicBadStruct::my_int32()
{
    return m_my_int32;
}

/*!
 * @brief This function copies the value in member my_string
 * @param _my_string New value to be copied in member my_string
 */
void BasicBadStruct::my_string(
        const std::string& _my_string)
{
    m_my_string = _my_string;
}

/*!
 * @brief This function moves the value in member my_string
 * @param _my_string New value to be moved in member my_string
 */
void BasicBadStruct::my_string(
        std::string&& _my_string)
{
    m_my_string = std::move(_my_string);
}

/*!
 * @brief This function returns a constant reference to member my_string
 * @return Constant reference to member my_string
 */
const std::string& BasicBadStruct::my_string() const
{
    return m_my_string;
}

/*!
 * @brief This function returns a reference to member my_string
 * @return Reference to member my_string
 */
std::string& BasicBadStruct::my_string()
{
    return m_my_string;
}


size_t BasicBadStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return BasicBadStruct_max_key_cdr_typesize;
}

bool BasicBadStruct::isKeyDefined()
{
    return false;
}

void BasicBadStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

BasicWideStruct::BasicWideStruct()
{






    // Just to register all known types
    registerTypesTypes();
}

BasicWideStruct::~BasicWideStruct()
{





}

BasicWideStruct::BasicWideStruct(
        const BasicWideStruct& x)
{
    m_my_bool = x.m_my_bool;
    m_my_int32 = x.m_my_int32;
    m_my_string = x.m_my_string;
    m_new_int32 = x.m_new_int32;
    m_new_string = x.m_new_string;
}

BasicWideStruct::BasicWideStruct(
        BasicWideStruct&& x) noexcept 
{
    m_my_bool = x.m_my_bool;
    m_my_int32 = x.m_my_int32;
    m_my_string = std::move(x.m_my_string);
    m_new_int32 = x.m_new_int32;
    m_new_string = std::move(x.m_new_string);
}

BasicWideStruct& BasicWideStruct::operator =(
        const BasicWideStruct& x)
{

    m_my_bool = x.m_my_bool;
    m_my_int32 = x.m_my_int32;
    m_my_string = x.m_my_string;
    m_new_int32 = x.m_new_int32;
    m_new_string = x.m_new_string;

    return *this;
}

BasicWideStruct& BasicWideStruct::operator =(
        BasicWideStruct&& x) noexcept
{

    m_my_bool = x.m_my_bool;
    m_my_int32 = x.m_my_int32;
    m_my_string = std::move(x.m_my_string);
    m_new_int32 = x.m_new_int32;
    m_new_string = std::move(x.m_new_string);

    return *this;
}

bool BasicWideStruct::operator ==(
        const BasicWideStruct& x) const
{

    return (m_my_bool == x.m_my_bool && m_my_int32 == x.m_my_int32 && m_my_string == x.m_my_string && m_new_int32 == x.m_new_int32 && m_new_string == x.m_new_string);
}

bool BasicWideStruct::operator !=(
        const BasicWideStruct& x) const
{
    return !(*this == x);
}

size_t BasicWideStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return BasicWideStruct_max_cdr_typesize;
}

size_t BasicWideStruct::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const BasicWideStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_bool, current_alignment);
                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1), data.m_my_int32, current_alignment);
                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2), data.m_my_string, current_alignment);
                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3), data.m_new_int32, current_alignment);
                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(4), data.m_new_string, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void BasicWideStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_bool;scdr << eprosima::fastcdr::MemberId(1) << m_my_int32;scdr << eprosima::fastcdr::MemberId(2) << m_my_string;scdr << eprosima::fastcdr::MemberId(3) << m_new_int32;scdr << eprosima::fastcdr::MemberId(4) << m_new_string;

    scdr.end_serialize_type(current_state);
}

void BasicWideStruct::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                            dcdr >> m_my_bool;
                                            break;
                                        
                                        case 1:
                                            dcdr >> m_my_int32;
                                            break;
                                        
                                        case 2:
                                            dcdr >> m_my_string;
                                            break;
                                        
                                        case 3:
                                            dcdr >> m_new_int32;
                                            break;
                                        
                    case 4:
                        dcdr >> m_new_string;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function sets a value in member my_bool
 * @param _my_bool New value for member my_bool
 */
void BasicWideStruct::my_bool(
        bool _my_bool)
{
    m_my_bool = _my_bool;
}

/*!
 * @brief This function returns the value of member my_bool
 * @return Value of member my_bool
 */
bool BasicWideStruct::my_bool() const
{
    return m_my_bool;
}

/*!
 * @brief This function returns a reference to member my_bool
 * @return Reference to member my_bool
 */
bool& BasicWideStruct::my_bool()
{
    return m_my_bool;
}

/*!
 * @brief This function sets a value in member my_int32
 * @param _my_int32 New value for member my_int32
 */
void BasicWideStruct::my_int32(
        int32_t _my_int32)
{
    m_my_int32 = _my_int32;
}

/*!
 * @brief This function returns the value of member my_int32
 * @return Value of member my_int32
 */
int32_t BasicWideStruct::my_int32() const
{
    return m_my_int32;
}

/*!
 * @brief This function returns a reference to member my_int32
 * @return Reference to member my_int32
 */
int32_t& BasicWideStruct::my_int32()
{
    return m_my_int32;
}

/*!
 * @brief This function copies the value in member my_string
 * @param _my_string New value to be copied in member my_string
 */
void BasicWideStruct::my_string(
        const std::string& _my_string)
{
    m_my_string = _my_string;
}

/*!
 * @brief This function moves the value in member my_string
 * @param _my_string New value to be moved in member my_string
 */
void BasicWideStruct::my_string(
        std::string&& _my_string)
{
    m_my_string = std::move(_my_string);
}

/*!
 * @brief This function returns a constant reference to member my_string
 * @return Constant reference to member my_string
 */
const std::string& BasicWideStruct::my_string() const
{
    return m_my_string;
}

/*!
 * @brief This function returns a reference to member my_string
 * @return Reference to member my_string
 */
std::string& BasicWideStruct::my_string()
{
    return m_my_string;
}
/*!
 * @brief This function sets a value in member new_int32
 * @param _new_int32 New value for member new_int32
 */
void BasicWideStruct::new_int32(
        int32_t _new_int32)
{
    m_new_int32 = _new_int32;
}

/*!
 * @brief This function returns the value of member new_int32
 * @return Value of member new_int32
 */
int32_t BasicWideStruct::new_int32() const
{
    return m_new_int32;
}

/*!
 * @brief This function returns a reference to member new_int32
 * @return Reference to member new_int32
 */
int32_t& BasicWideStruct::new_int32()
{
    return m_new_int32;
}

/*!
 * @brief This function copies the value in member new_string
 * @param _new_string New value to be copied in member new_string
 */
void BasicWideStruct::new_string(
        const std::string& _new_string)
{
    m_new_string = _new_string;
}

/*!
 * @brief This function moves the value in member new_string
 * @param _new_string New value to be moved in member new_string
 */
void BasicWideStruct::new_string(
        std::string&& _new_string)
{
    m_new_string = std::move(_new_string);
}

/*!
 * @brief This function returns a constant reference to member new_string
 * @return Constant reference to member new_string
 */
const std::string& BasicWideStruct::new_string() const
{
    return m_new_string;
}

/*!
 * @brief This function returns a reference to member new_string
 * @return Reference to member new_string
 */
std::string& BasicWideStruct::new_string()
{
    return m_new_string;
}


size_t BasicWideStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return BasicWideStruct_max_key_cdr_typesize;
}

bool BasicWideStruct::isKeyDefined()
{
    return false;
}

void BasicWideStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

BadBasicWideStruct::BadBasicWideStruct()
{






    // Just to register all known types
    registerTypesTypes();
}

BadBasicWideStruct::~BadBasicWideStruct()
{





}

BadBasicWideStruct::BadBasicWideStruct(
        const BadBasicWideStruct& x)
{
    m_new_int32 = x.m_new_int32;
    m_new_string = x.m_new_string;
    m_my_bool = x.m_my_bool;
    m_my_int32 = x.m_my_int32;
    m_my_string = x.m_my_string;
}

BadBasicWideStruct::BadBasicWideStruct(
        BadBasicWideStruct&& x) noexcept 
{
    m_new_int32 = x.m_new_int32;
    m_new_string = std::move(x.m_new_string);
    m_my_bool = x.m_my_bool;
    m_my_int32 = x.m_my_int32;
    m_my_string = std::move(x.m_my_string);
}

BadBasicWideStruct& BadBasicWideStruct::operator =(
        const BadBasicWideStruct& x)
{

    m_new_int32 = x.m_new_int32;
    m_new_string = x.m_new_string;
    m_my_bool = x.m_my_bool;
    m_my_int32 = x.m_my_int32;
    m_my_string = x.m_my_string;

    return *this;
}

BadBasicWideStruct& BadBasicWideStruct::operator =(
        BadBasicWideStruct&& x) noexcept
{

    m_new_int32 = x.m_new_int32;
    m_new_string = std::move(x.m_new_string);
    m_my_bool = x.m_my_bool;
    m_my_int32 = x.m_my_int32;
    m_my_string = std::move(x.m_my_string);

    return *this;
}

bool BadBasicWideStruct::operator ==(
        const BadBasicWideStruct& x) const
{

    return (m_new_int32 == x.m_new_int32 && m_new_string == x.m_new_string && m_my_bool == x.m_my_bool && m_my_int32 == x.m_my_int32 && m_my_string == x.m_my_string);
}

bool BadBasicWideStruct::operator !=(
        const BadBasicWideStruct& x) const
{
    return !(*this == x);
}

size_t BadBasicWideStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return BadBasicWideStruct_max_cdr_typesize;
}

size_t BadBasicWideStruct::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const BadBasicWideStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_new_int32, current_alignment);
                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1), data.m_new_string, current_alignment);
                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2), data.m_my_bool, current_alignment);
                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3), data.m_my_int32, current_alignment);
                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(4), data.m_my_string, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void BadBasicWideStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_new_int32;scdr << eprosima::fastcdr::MemberId(1) << m_new_string;scdr << eprosima::fastcdr::MemberId(2) << m_my_bool;scdr << eprosima::fastcdr::MemberId(3) << m_my_int32;scdr << eprosima::fastcdr::MemberId(4) << m_my_string;

    scdr.end_serialize_type(current_state);
}

void BadBasicWideStruct::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                            dcdr >> m_new_int32;
                                            break;
                                        
                                        case 1:
                                            dcdr >> m_new_string;
                                            break;
                                        
                                        case 2:
                                            dcdr >> m_my_bool;
                                            break;
                                        
                                        case 3:
                                            dcdr >> m_my_int32;
                                            break;
                                        
                    case 4:
                        dcdr >> m_my_string;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function sets a value in member new_int32
 * @param _new_int32 New value for member new_int32
 */
void BadBasicWideStruct::new_int32(
        int32_t _new_int32)
{
    m_new_int32 = _new_int32;
}

/*!
 * @brief This function returns the value of member new_int32
 * @return Value of member new_int32
 */
int32_t BadBasicWideStruct::new_int32() const
{
    return m_new_int32;
}

/*!
 * @brief This function returns a reference to member new_int32
 * @return Reference to member new_int32
 */
int32_t& BadBasicWideStruct::new_int32()
{
    return m_new_int32;
}

/*!
 * @brief This function copies the value in member new_string
 * @param _new_string New value to be copied in member new_string
 */
void BadBasicWideStruct::new_string(
        const std::string& _new_string)
{
    m_new_string = _new_string;
}

/*!
 * @brief This function moves the value in member new_string
 * @param _new_string New value to be moved in member new_string
 */
void BadBasicWideStruct::new_string(
        std::string&& _new_string)
{
    m_new_string = std::move(_new_string);
}

/*!
 * @brief This function returns a constant reference to member new_string
 * @return Constant reference to member new_string
 */
const std::string& BadBasicWideStruct::new_string() const
{
    return m_new_string;
}

/*!
 * @brief This function returns a reference to member new_string
 * @return Reference to member new_string
 */
std::string& BadBasicWideStruct::new_string()
{
    return m_new_string;
}
/*!
 * @brief This function sets a value in member my_bool
 * @param _my_bool New value for member my_bool
 */
void BadBasicWideStruct::my_bool(
        bool _my_bool)
{
    m_my_bool = _my_bool;
}

/*!
 * @brief This function returns the value of member my_bool
 * @return Value of member my_bool
 */
bool BadBasicWideStruct::my_bool() const
{
    return m_my_bool;
}

/*!
 * @brief This function returns a reference to member my_bool
 * @return Reference to member my_bool
 */
bool& BadBasicWideStruct::my_bool()
{
    return m_my_bool;
}

/*!
 * @brief This function sets a value in member my_int32
 * @param _my_int32 New value for member my_int32
 */
void BadBasicWideStruct::my_int32(
        int32_t _my_int32)
{
    m_my_int32 = _my_int32;
}

/*!
 * @brief This function returns the value of member my_int32
 * @return Value of member my_int32
 */
int32_t BadBasicWideStruct::my_int32() const
{
    return m_my_int32;
}

/*!
 * @brief This function returns a reference to member my_int32
 * @return Reference to member my_int32
 */
int32_t& BadBasicWideStruct::my_int32()
{
    return m_my_int32;
}

/*!
 * @brief This function copies the value in member my_string
 * @param _my_string New value to be copied in member my_string
 */
void BadBasicWideStruct::my_string(
        const std::string& _my_string)
{
    m_my_string = _my_string;
}

/*!
 * @brief This function moves the value in member my_string
 * @param _my_string New value to be moved in member my_string
 */
void BadBasicWideStruct::my_string(
        std::string&& _my_string)
{
    m_my_string = std::move(_my_string);
}

/*!
 * @brief This function returns a constant reference to member my_string
 * @return Constant reference to member my_string
 */
const std::string& BadBasicWideStruct::my_string() const
{
    return m_my_string;
}

/*!
 * @brief This function returns a reference to member my_string
 * @return Reference to member my_string
 */
std::string& BadBasicWideStruct::my_string()
{
    return m_my_string;
}


size_t BadBasicWideStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return BadBasicWideStruct_max_key_cdr_typesize;
}

bool BadBasicWideStruct::isKeyDefined()
{
    return false;
}

void BadBasicWideStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

StringStruct::StringStruct()
{

    // Just to register all known types
    registerTypesTypes();
}

StringStruct::~StringStruct()
{
}

StringStruct::StringStruct(
        const StringStruct& x)
{
    m_my_string = x.m_my_string;
}

StringStruct::StringStruct(
        StringStruct&& x) noexcept 
{
    m_my_string = std::move(x.m_my_string);
}

StringStruct& StringStruct::operator =(
        const StringStruct& x)
{

    m_my_string = x.m_my_string;

    return *this;
}

StringStruct& StringStruct::operator =(
        StringStruct&& x) noexcept
{

    m_my_string = std::move(x.m_my_string);

    return *this;
}

bool StringStruct::operator ==(
        const StringStruct& x) const
{

    return (m_my_string == x.m_my_string);
}

bool StringStruct::operator !=(
        const StringStruct& x) const
{
    return !(*this == x);
}

size_t StringStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StringStruct_max_cdr_typesize;
}

size_t StringStruct::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const StringStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_string, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void StringStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_string;

    scdr.end_serialize_type(current_state);
}

void StringStruct::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m_my_string;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function copies the value in member my_string
 * @param _my_string New value to be copied in member my_string
 */
void StringStruct::my_string(
        const std::string& _my_string)
{
    m_my_string = _my_string;
}

/*!
 * @brief This function moves the value in member my_string
 * @param _my_string New value to be moved in member my_string
 */
void StringStruct::my_string(
        std::string&& _my_string)
{
    m_my_string = std::move(_my_string);
}

/*!
 * @brief This function returns a constant reference to member my_string
 * @return Constant reference to member my_string
 */
const std::string& StringStruct::my_string() const
{
    return m_my_string;
}

/*!
 * @brief This function returns a reference to member my_string
 * @return Reference to member my_string
 */
std::string& StringStruct::my_string()
{
    return m_my_string;
}


size_t StringStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return StringStruct_max_key_cdr_typesize;
}

bool StringStruct::isKeyDefined()
{
    return false;
}

void StringStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

LargeStringStruct::LargeStringStruct()
{

    // Just to register all known types
    registerTypesTypes();
}

LargeStringStruct::~LargeStringStruct()
{
}

LargeStringStruct::LargeStringStruct(
        const LargeStringStruct& x)
{
    m_my_large_string = x.m_my_large_string;
}

LargeStringStruct::LargeStringStruct(
        LargeStringStruct&& x) noexcept 
{
    m_my_large_string = std::move(x.m_my_large_string);
}

LargeStringStruct& LargeStringStruct::operator =(
        const LargeStringStruct& x)
{

    m_my_large_string = x.m_my_large_string;

    return *this;
}

LargeStringStruct& LargeStringStruct::operator =(
        LargeStringStruct&& x) noexcept
{

    m_my_large_string = std::move(x.m_my_large_string);

    return *this;
}

bool LargeStringStruct::operator ==(
        const LargeStringStruct& x) const
{

    return (m_my_large_string == x.m_my_large_string);
}

bool LargeStringStruct::operator !=(
        const LargeStringStruct& x) const
{
    return !(*this == x);
}

size_t LargeStringStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return LargeStringStruct_max_cdr_typesize;
}

size_t LargeStringStruct::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const LargeStringStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_large_string, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void LargeStringStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_large_string;

    scdr.end_serialize_type(current_state);
}

void LargeStringStruct::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m_my_large_string;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function copies the value in member my_large_string
 * @param _my_large_string New value to be copied in member my_large_string
 */
void LargeStringStruct::my_large_string(
        const eprosima::fastcdr::fixed_string<41925>& _my_large_string)
{
    m_my_large_string = _my_large_string;
}

/*!
 * @brief This function moves the value in member my_large_string
 * @param _my_large_string New value to be moved in member my_large_string
 */
void LargeStringStruct::my_large_string(
        eprosima::fastcdr::fixed_string<41925>&& _my_large_string)
{
    m_my_large_string = std::move(_my_large_string);
}

/*!
 * @brief This function returns a constant reference to member my_large_string
 * @return Constant reference to member my_large_string
 */
const eprosima::fastcdr::fixed_string<41925>& LargeStringStruct::my_large_string() const
{
    return m_my_large_string;
}

/*!
 * @brief This function returns a reference to member my_large_string
 * @return Reference to member my_large_string
 */
eprosima::fastcdr::fixed_string<41925>& LargeStringStruct::my_large_string()
{
    return m_my_large_string;
}


size_t LargeStringStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return LargeStringStruct_max_key_cdr_typesize;
}

bool LargeStringStruct::isKeyDefined()
{
    return false;
}

void LargeStringStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

WStringStruct::WStringStruct()
{

    // Just to register all known types
    registerTypesTypes();
}

WStringStruct::~WStringStruct()
{
}

WStringStruct::WStringStruct(
        const WStringStruct& x)
{
    m_my_wstring = x.m_my_wstring;
}

WStringStruct::WStringStruct(
        WStringStruct&& x) noexcept 
{
    m_my_wstring = std::move(x.m_my_wstring);
}

WStringStruct& WStringStruct::operator =(
        const WStringStruct& x)
{

    m_my_wstring = x.m_my_wstring;

    return *this;
}

WStringStruct& WStringStruct::operator =(
        WStringStruct&& x) noexcept
{

    m_my_wstring = std::move(x.m_my_wstring);

    return *this;
}

bool WStringStruct::operator ==(
        const WStringStruct& x) const
{

    return (m_my_wstring == x.m_my_wstring);
}

bool WStringStruct::operator !=(
        const WStringStruct& x) const
{
    return !(*this == x);
}

size_t WStringStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return WStringStruct_max_cdr_typesize;
}

size_t WStringStruct::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const WStringStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_wstring, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void WStringStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_wstring;

    scdr.end_serialize_type(current_state);
}

void WStringStruct::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m_my_wstring;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function copies the value in member my_wstring
 * @param _my_wstring New value to be copied in member my_wstring
 */
void WStringStruct::my_wstring(
        const std::wstring& _my_wstring)
{
    m_my_wstring = _my_wstring;
}

/*!
 * @brief This function moves the value in member my_wstring
 * @param _my_wstring New value to be moved in member my_wstring
 */
void WStringStruct::my_wstring(
        std::wstring&& _my_wstring)
{
    m_my_wstring = std::move(_my_wstring);
}

/*!
 * @brief This function returns a constant reference to member my_wstring
 * @return Constant reference to member my_wstring
 */
const std::wstring& WStringStruct::my_wstring() const
{
    return m_my_wstring;
}

/*!
 * @brief This function returns a reference to member my_wstring
 * @return Reference to member my_wstring
 */
std::wstring& WStringStruct::my_wstring()
{
    return m_my_wstring;
}


size_t WStringStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return WStringStruct_max_key_cdr_typesize;
}

bool WStringStruct::isKeyDefined()
{
    return false;
}

void WStringStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

LargeWStringStruct::LargeWStringStruct()
{

    // Just to register all known types
    registerTypesTypes();
}

LargeWStringStruct::~LargeWStringStruct()
{
}

LargeWStringStruct::LargeWStringStruct(
        const LargeWStringStruct& x)
{
    m_my_large_wstring = x.m_my_large_wstring;
}

LargeWStringStruct::LargeWStringStruct(
        LargeWStringStruct&& x) noexcept 
{
    m_my_large_wstring = std::move(x.m_my_large_wstring);
}

LargeWStringStruct& LargeWStringStruct::operator =(
        const LargeWStringStruct& x)
{

    m_my_large_wstring = x.m_my_large_wstring;

    return *this;
}

LargeWStringStruct& LargeWStringStruct::operator =(
        LargeWStringStruct&& x) noexcept
{

    m_my_large_wstring = std::move(x.m_my_large_wstring);

    return *this;
}

bool LargeWStringStruct::operator ==(
        const LargeWStringStruct& x) const
{

    return (m_my_large_wstring == x.m_my_large_wstring);
}

bool LargeWStringStruct::operator !=(
        const LargeWStringStruct& x) const
{
    return !(*this == x);
}

size_t LargeWStringStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return LargeWStringStruct_max_cdr_typesize;
}

size_t LargeWStringStruct::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const LargeWStringStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_large_wstring, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void LargeWStringStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_large_wstring;

    scdr.end_serialize_type(current_state);
}

void LargeWStringStruct::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m_my_large_wstring;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function copies the value in member my_large_wstring
 * @param _my_large_wstring New value to be copied in member my_large_wstring
 */
void LargeWStringStruct::my_large_wstring(
        const std::wstring& _my_large_wstring)
{
    m_my_large_wstring = _my_large_wstring;
}

/*!
 * @brief This function moves the value in member my_large_wstring
 * @param _my_large_wstring New value to be moved in member my_large_wstring
 */
void LargeWStringStruct::my_large_wstring(
        std::wstring&& _my_large_wstring)
{
    m_my_large_wstring = std::move(_my_large_wstring);
}

/*!
 * @brief This function returns a constant reference to member my_large_wstring
 * @return Constant reference to member my_large_wstring
 */
const std::wstring& LargeWStringStruct::my_large_wstring() const
{
    return m_my_large_wstring;
}

/*!
 * @brief This function returns a reference to member my_large_wstring
 * @return Reference to member my_large_wstring
 */
std::wstring& LargeWStringStruct::my_large_wstring()
{
    return m_my_large_wstring;
}


size_t LargeWStringStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return LargeWStringStruct_max_key_cdr_typesize;
}

bool LargeWStringStruct::isKeyDefined()
{
    return false;
}

void LargeWStringStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

ArrayStruct::ArrayStruct()
{

    // Just to register all known types
    registerTypesTypes();
}

ArrayStruct::~ArrayStruct()
{
}

ArrayStruct::ArrayStruct(
        const ArrayStruct& x)
{
    m_my_array = x.m_my_array;
}

ArrayStruct::ArrayStruct(
        ArrayStruct&& x) noexcept 
{
    m_my_array = std::move(x.m_my_array);
}

ArrayStruct& ArrayStruct::operator =(
        const ArrayStruct& x)
{

    m_my_array = x.m_my_array;

    return *this;
}

ArrayStruct& ArrayStruct::operator =(
        ArrayStruct&& x) noexcept
{

    m_my_array = std::move(x.m_my_array);

    return *this;
}

bool ArrayStruct::operator ==(
        const ArrayStruct& x) const
{

    return (m_my_array == x.m_my_array);
}

bool ArrayStruct::operator !=(
        const ArrayStruct& x) const
{
    return !(*this == x);
}

size_t ArrayStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayStruct_max_cdr_typesize;
}

size_t ArrayStruct::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const ArrayStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_array, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void ArrayStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_array;

    scdr.end_serialize_type(current_state);
}

void ArrayStruct::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m_my_array;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function copies the value in member my_array
 * @param _my_array New value to be copied in member my_array
 */
void ArrayStruct::my_array(
        const std::array<int32_t, 2>& _my_array)
{
    m_my_array = _my_array;
}

/*!
 * @brief This function moves the value in member my_array
 * @param _my_array New value to be moved in member my_array
 */
void ArrayStruct::my_array(
        std::array<int32_t, 2>&& _my_array)
{
    m_my_array = std::move(_my_array);
}

/*!
 * @brief This function returns a constant reference to member my_array
 * @return Constant reference to member my_array
 */
const std::array<int32_t, 2>& ArrayStruct::my_array() const
{
    return m_my_array;
}

/*!
 * @brief This function returns a reference to member my_array
 * @return Reference to member my_array
 */
std::array<int32_t, 2>& ArrayStruct::my_array()
{
    return m_my_array;
}


size_t ArrayStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayStruct_max_key_cdr_typesize;
}

bool ArrayStruct::isKeyDefined()
{
    return false;
}

void ArrayStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

ArrayStructEqual::ArrayStructEqual()
{

    // Just to register all known types
    registerTypesTypes();
}

ArrayStructEqual::~ArrayStructEqual()
{
}

ArrayStructEqual::ArrayStructEqual(
        const ArrayStructEqual& x)
{
    m_my_array_equal = x.m_my_array_equal;
}

ArrayStructEqual::ArrayStructEqual(
        ArrayStructEqual&& x) noexcept 
{
    m_my_array_equal = std::move(x.m_my_array_equal);
}

ArrayStructEqual& ArrayStructEqual::operator =(
        const ArrayStructEqual& x)
{

    m_my_array_equal = x.m_my_array_equal;

    return *this;
}

ArrayStructEqual& ArrayStructEqual::operator =(
        ArrayStructEqual&& x) noexcept
{

    m_my_array_equal = std::move(x.m_my_array_equal);

    return *this;
}

bool ArrayStructEqual::operator ==(
        const ArrayStructEqual& x) const
{

    return (m_my_array_equal == x.m_my_array_equal);
}

bool ArrayStructEqual::operator !=(
        const ArrayStructEqual& x) const
{
    return !(*this == x);
}

size_t ArrayStructEqual::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayStructEqual_max_cdr_typesize;
}

size_t ArrayStructEqual::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const ArrayStructEqual& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_array_equal, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void ArrayStructEqual::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_array_equal;

    scdr.end_serialize_type(current_state);
}

void ArrayStructEqual::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m_my_array_equal;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function copies the value in member my_array_equal
 * @param _my_array_equal New value to be copied in member my_array_equal
 */
void ArrayStructEqual::my_array_equal(
        const std::array<int32_t, 2>& _my_array_equal)
{
    m_my_array_equal = _my_array_equal;
}

/*!
 * @brief This function moves the value in member my_array_equal
 * @param _my_array_equal New value to be moved in member my_array_equal
 */
void ArrayStructEqual::my_array_equal(
        std::array<int32_t, 2>&& _my_array_equal)
{
    m_my_array_equal = std::move(_my_array_equal);
}

/*!
 * @brief This function returns a constant reference to member my_array_equal
 * @return Constant reference to member my_array_equal
 */
const std::array<int32_t, 2>& ArrayStructEqual::my_array_equal() const
{
    return m_my_array_equal;
}

/*!
 * @brief This function returns a reference to member my_array_equal
 * @return Reference to member my_array_equal
 */
std::array<int32_t, 2>& ArrayStructEqual::my_array_equal()
{
    return m_my_array_equal;
}


size_t ArrayStructEqual::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayStructEqual_max_key_cdr_typesize;
}

bool ArrayStructEqual::isKeyDefined()
{
    return false;
}

void ArrayStructEqual::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

ArrayBadStruct::ArrayBadStruct()
{

    // Just to register all known types
    registerTypesTypes();
}

ArrayBadStruct::~ArrayBadStruct()
{
}

ArrayBadStruct::ArrayBadStruct(
        const ArrayBadStruct& x)
{
    m_my_array = x.m_my_array;
}

ArrayBadStruct::ArrayBadStruct(
        ArrayBadStruct&& x) noexcept 
{
    m_my_array = std::move(x.m_my_array);
}

ArrayBadStruct& ArrayBadStruct::operator =(
        const ArrayBadStruct& x)
{

    m_my_array = x.m_my_array;

    return *this;
}

ArrayBadStruct& ArrayBadStruct::operator =(
        ArrayBadStruct&& x) noexcept
{

    m_my_array = std::move(x.m_my_array);

    return *this;
}

bool ArrayBadStruct::operator ==(
        const ArrayBadStruct& x) const
{

    return (m_my_array == x.m_my_array);
}

bool ArrayBadStruct::operator !=(
        const ArrayBadStruct& x) const
{
    return !(*this == x);
}

size_t ArrayBadStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayBadStruct_max_cdr_typesize;
}

size_t ArrayBadStruct::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const ArrayBadStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_array, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void ArrayBadStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_array;

    scdr.end_serialize_type(current_state);
}

void ArrayBadStruct::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m_my_array;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function copies the value in member my_array
 * @param _my_array New value to be copied in member my_array
 */
void ArrayBadStruct::my_array(
        const std::array<uint8_t, 2>& _my_array)
{
    m_my_array = _my_array;
}

/*!
 * @brief This function moves the value in member my_array
 * @param _my_array New value to be moved in member my_array
 */
void ArrayBadStruct::my_array(
        std::array<uint8_t, 2>&& _my_array)
{
    m_my_array = std::move(_my_array);
}

/*!
 * @brief This function returns a constant reference to member my_array
 * @return Constant reference to member my_array
 */
const std::array<uint8_t, 2>& ArrayBadStruct::my_array() const
{
    return m_my_array;
}

/*!
 * @brief This function returns a reference to member my_array
 * @return Reference to member my_array
 */
std::array<uint8_t, 2>& ArrayBadStruct::my_array()
{
    return m_my_array;
}


size_t ArrayBadStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayBadStruct_max_key_cdr_typesize;
}

bool ArrayBadStruct::isKeyDefined()
{
    return false;
}

void ArrayBadStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

ArrayDimensionsStruct::ArrayDimensionsStruct()
{

    // Just to register all known types
    registerTypesTypes();
}

ArrayDimensionsStruct::~ArrayDimensionsStruct()
{
}

ArrayDimensionsStruct::ArrayDimensionsStruct(
        const ArrayDimensionsStruct& x)
{
    m_my_array = x.m_my_array;
}

ArrayDimensionsStruct::ArrayDimensionsStruct(
        ArrayDimensionsStruct&& x) noexcept 
{
    m_my_array = std::move(x.m_my_array);
}

ArrayDimensionsStruct& ArrayDimensionsStruct::operator =(
        const ArrayDimensionsStruct& x)
{

    m_my_array = x.m_my_array;

    return *this;
}

ArrayDimensionsStruct& ArrayDimensionsStruct::operator =(
        ArrayDimensionsStruct&& x) noexcept
{

    m_my_array = std::move(x.m_my_array);

    return *this;
}

bool ArrayDimensionsStruct::operator ==(
        const ArrayDimensionsStruct& x) const
{

    return (m_my_array == x.m_my_array);
}

bool ArrayDimensionsStruct::operator !=(
        const ArrayDimensionsStruct& x) const
{
    return !(*this == x);
}

size_t ArrayDimensionsStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayDimensionsStruct_max_cdr_typesize;
}

size_t ArrayDimensionsStruct::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const ArrayDimensionsStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_array, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void ArrayDimensionsStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_array;

    scdr.end_serialize_type(current_state);
}

void ArrayDimensionsStruct::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m_my_array;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function copies the value in member my_array
 * @param _my_array New value to be copied in member my_array
 */
void ArrayDimensionsStruct::my_array(
        const std::array<std::array<int32_t, 2>, 2>& _my_array)
{
    m_my_array = _my_array;
}

/*!
 * @brief This function moves the value in member my_array
 * @param _my_array New value to be moved in member my_array
 */
void ArrayDimensionsStruct::my_array(
        std::array<std::array<int32_t, 2>, 2>&& _my_array)
{
    m_my_array = std::move(_my_array);
}

/*!
 * @brief This function returns a constant reference to member my_array
 * @return Constant reference to member my_array
 */
const std::array<std::array<int32_t, 2>, 2>& ArrayDimensionsStruct::my_array() const
{
    return m_my_array;
}

/*!
 * @brief This function returns a reference to member my_array
 * @return Reference to member my_array
 */
std::array<std::array<int32_t, 2>, 2>& ArrayDimensionsStruct::my_array()
{
    return m_my_array;
}


size_t ArrayDimensionsStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArrayDimensionsStruct_max_key_cdr_typesize;
}

bool ArrayDimensionsStruct::isKeyDefined()
{
    return false;
}

void ArrayDimensionsStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

ArraySizeStruct::ArraySizeStruct()
{

    // Just to register all known types
    registerTypesTypes();
}

ArraySizeStruct::~ArraySizeStruct()
{
}

ArraySizeStruct::ArraySizeStruct(
        const ArraySizeStruct& x)
{
    m_my_array = x.m_my_array;
}

ArraySizeStruct::ArraySizeStruct(
        ArraySizeStruct&& x) noexcept 
{
    m_my_array = std::move(x.m_my_array);
}

ArraySizeStruct& ArraySizeStruct::operator =(
        const ArraySizeStruct& x)
{

    m_my_array = x.m_my_array;

    return *this;
}

ArraySizeStruct& ArraySizeStruct::operator =(
        ArraySizeStruct&& x) noexcept
{

    m_my_array = std::move(x.m_my_array);

    return *this;
}

bool ArraySizeStruct::operator ==(
        const ArraySizeStruct& x) const
{

    return (m_my_array == x.m_my_array);
}

bool ArraySizeStruct::operator !=(
        const ArraySizeStruct& x) const
{
    return !(*this == x);
}

size_t ArraySizeStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySizeStruct_max_cdr_typesize;
}

size_t ArraySizeStruct::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const ArraySizeStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_array, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void ArraySizeStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_array;

    scdr.end_serialize_type(current_state);
}

void ArraySizeStruct::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m_my_array;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function copies the value in member my_array
 * @param _my_array New value to be copied in member my_array
 */
void ArraySizeStruct::my_array(
        const std::array<int32_t, 5>& _my_array)
{
    m_my_array = _my_array;
}

/*!
 * @brief This function moves the value in member my_array
 * @param _my_array New value to be moved in member my_array
 */
void ArraySizeStruct::my_array(
        std::array<int32_t, 5>&& _my_array)
{
    m_my_array = std::move(_my_array);
}

/*!
 * @brief This function returns a constant reference to member my_array
 * @return Constant reference to member my_array
 */
const std::array<int32_t, 5>& ArraySizeStruct::my_array() const
{
    return m_my_array;
}

/*!
 * @brief This function returns a reference to member my_array
 * @return Reference to member my_array
 */
std::array<int32_t, 5>& ArraySizeStruct::my_array()
{
    return m_my_array;
}


size_t ArraySizeStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ArraySizeStruct_max_key_cdr_typesize;
}

bool ArraySizeStruct::isKeyDefined()
{
    return false;
}

void ArraySizeStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

SequenceStruct::SequenceStruct()
{

    // Just to register all known types
    registerTypesTypes();
}

SequenceStruct::~SequenceStruct()
{
}

SequenceStruct::SequenceStruct(
        const SequenceStruct& x)
{
    m_my_sequence = x.m_my_sequence;
}

SequenceStruct::SequenceStruct(
        SequenceStruct&& x) noexcept 
{
    m_my_sequence = std::move(x.m_my_sequence);
}

SequenceStruct& SequenceStruct::operator =(
        const SequenceStruct& x)
{

    m_my_sequence = x.m_my_sequence;

    return *this;
}

SequenceStruct& SequenceStruct::operator =(
        SequenceStruct&& x) noexcept
{

    m_my_sequence = std::move(x.m_my_sequence);

    return *this;
}

bool SequenceStruct::operator ==(
        const SequenceStruct& x) const
{

    return (m_my_sequence == x.m_my_sequence);
}

bool SequenceStruct::operator !=(
        const SequenceStruct& x) const
{
    return !(*this == x);
}

size_t SequenceStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceStruct_max_cdr_typesize;
}

size_t SequenceStruct::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const SequenceStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_sequence, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void SequenceStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_sequence;

    scdr.end_serialize_type(current_state);
}

void SequenceStruct::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m_my_sequence;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function copies the value in member my_sequence
 * @param _my_sequence New value to be copied in member my_sequence
 */
void SequenceStruct::my_sequence(
        const std::vector<int32_t>& _my_sequence)
{
    m_my_sequence = _my_sequence;
}

/*!
 * @brief This function moves the value in member my_sequence
 * @param _my_sequence New value to be moved in member my_sequence
 */
void SequenceStruct::my_sequence(
        std::vector<int32_t>&& _my_sequence)
{
    m_my_sequence = std::move(_my_sequence);
}

/*!
 * @brief This function returns a constant reference to member my_sequence
 * @return Constant reference to member my_sequence
 */
const std::vector<int32_t>& SequenceStruct::my_sequence() const
{
    return m_my_sequence;
}

/*!
 * @brief This function returns a reference to member my_sequence
 * @return Reference to member my_sequence
 */
std::vector<int32_t>& SequenceStruct::my_sequence()
{
    return m_my_sequence;
}


size_t SequenceStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceStruct_max_key_cdr_typesize;
}

bool SequenceStruct::isKeyDefined()
{
    return false;
}

void SequenceStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

SequenceStructEqual::SequenceStructEqual()
{

    // Just to register all known types
    registerTypesTypes();
}

SequenceStructEqual::~SequenceStructEqual()
{
}

SequenceStructEqual::SequenceStructEqual(
        const SequenceStructEqual& x)
{
    m_my_sequence_equal = x.m_my_sequence_equal;
}

SequenceStructEqual::SequenceStructEqual(
        SequenceStructEqual&& x) noexcept 
{
    m_my_sequence_equal = std::move(x.m_my_sequence_equal);
}

SequenceStructEqual& SequenceStructEqual::operator =(
        const SequenceStructEqual& x)
{

    m_my_sequence_equal = x.m_my_sequence_equal;

    return *this;
}

SequenceStructEqual& SequenceStructEqual::operator =(
        SequenceStructEqual&& x) noexcept
{

    m_my_sequence_equal = std::move(x.m_my_sequence_equal);

    return *this;
}

bool SequenceStructEqual::operator ==(
        const SequenceStructEqual& x) const
{

    return (m_my_sequence_equal == x.m_my_sequence_equal);
}

bool SequenceStructEqual::operator !=(
        const SequenceStructEqual& x) const
{
    return !(*this == x);
}

size_t SequenceStructEqual::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceStructEqual_max_cdr_typesize;
}

size_t SequenceStructEqual::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const SequenceStructEqual& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_sequence_equal, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void SequenceStructEqual::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_sequence_equal;

    scdr.end_serialize_type(current_state);
}

void SequenceStructEqual::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m_my_sequence_equal;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function copies the value in member my_sequence_equal
 * @param _my_sequence_equal New value to be copied in member my_sequence_equal
 */
void SequenceStructEqual::my_sequence_equal(
        const std::vector<int32_t>& _my_sequence_equal)
{
    m_my_sequence_equal = _my_sequence_equal;
}

/*!
 * @brief This function moves the value in member my_sequence_equal
 * @param _my_sequence_equal New value to be moved in member my_sequence_equal
 */
void SequenceStructEqual::my_sequence_equal(
        std::vector<int32_t>&& _my_sequence_equal)
{
    m_my_sequence_equal = std::move(_my_sequence_equal);
}

/*!
 * @brief This function returns a constant reference to member my_sequence_equal
 * @return Constant reference to member my_sequence_equal
 */
const std::vector<int32_t>& SequenceStructEqual::my_sequence_equal() const
{
    return m_my_sequence_equal;
}

/*!
 * @brief This function returns a reference to member my_sequence_equal
 * @return Reference to member my_sequence_equal
 */
std::vector<int32_t>& SequenceStructEqual::my_sequence_equal()
{
    return m_my_sequence_equal;
}


size_t SequenceStructEqual::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceStructEqual_max_key_cdr_typesize;
}

bool SequenceStructEqual::isKeyDefined()
{
    return false;
}

void SequenceStructEqual::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

SequenceBadStruct::SequenceBadStruct()
{

    // Just to register all known types
    registerTypesTypes();
}

SequenceBadStruct::~SequenceBadStruct()
{
}

SequenceBadStruct::SequenceBadStruct(
        const SequenceBadStruct& x)
{
    m_my_sequence = x.m_my_sequence;
}

SequenceBadStruct::SequenceBadStruct(
        SequenceBadStruct&& x) noexcept 
{
    m_my_sequence = std::move(x.m_my_sequence);
}

SequenceBadStruct& SequenceBadStruct::operator =(
        const SequenceBadStruct& x)
{

    m_my_sequence = x.m_my_sequence;

    return *this;
}

SequenceBadStruct& SequenceBadStruct::operator =(
        SequenceBadStruct&& x) noexcept
{

    m_my_sequence = std::move(x.m_my_sequence);

    return *this;
}

bool SequenceBadStruct::operator ==(
        const SequenceBadStruct& x) const
{

    return (m_my_sequence == x.m_my_sequence);
}

bool SequenceBadStruct::operator !=(
        const SequenceBadStruct& x) const
{
    return !(*this == x);
}

size_t SequenceBadStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceBadStruct_max_cdr_typesize;
}

size_t SequenceBadStruct::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const SequenceBadStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_sequence, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void SequenceBadStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_sequence;

    scdr.end_serialize_type(current_state);
}

void SequenceBadStruct::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m_my_sequence;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function copies the value in member my_sequence
 * @param _my_sequence New value to be copied in member my_sequence
 */
void SequenceBadStruct::my_sequence(
        const std::vector<uint8_t>& _my_sequence)
{
    m_my_sequence = _my_sequence;
}

/*!
 * @brief This function moves the value in member my_sequence
 * @param _my_sequence New value to be moved in member my_sequence
 */
void SequenceBadStruct::my_sequence(
        std::vector<uint8_t>&& _my_sequence)
{
    m_my_sequence = std::move(_my_sequence);
}

/*!
 * @brief This function returns a constant reference to member my_sequence
 * @return Constant reference to member my_sequence
 */
const std::vector<uint8_t>& SequenceBadStruct::my_sequence() const
{
    return m_my_sequence;
}

/*!
 * @brief This function returns a reference to member my_sequence
 * @return Reference to member my_sequence
 */
std::vector<uint8_t>& SequenceBadStruct::my_sequence()
{
    return m_my_sequence;
}


size_t SequenceBadStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceBadStruct_max_key_cdr_typesize;
}

bool SequenceBadStruct::isKeyDefined()
{
    return false;
}

void SequenceBadStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

SequenceBoundsStruct::SequenceBoundsStruct()
{

    // Just to register all known types
    registerTypesTypes();
}

SequenceBoundsStruct::~SequenceBoundsStruct()
{
}

SequenceBoundsStruct::SequenceBoundsStruct(
        const SequenceBoundsStruct& x)
{
    m_my_sequence = x.m_my_sequence;
}

SequenceBoundsStruct::SequenceBoundsStruct(
        SequenceBoundsStruct&& x) noexcept 
{
    m_my_sequence = std::move(x.m_my_sequence);
}

SequenceBoundsStruct& SequenceBoundsStruct::operator =(
        const SequenceBoundsStruct& x)
{

    m_my_sequence = x.m_my_sequence;

    return *this;
}

SequenceBoundsStruct& SequenceBoundsStruct::operator =(
        SequenceBoundsStruct&& x) noexcept
{

    m_my_sequence = std::move(x.m_my_sequence);

    return *this;
}

bool SequenceBoundsStruct::operator ==(
        const SequenceBoundsStruct& x) const
{

    return (m_my_sequence == x.m_my_sequence);
}

bool SequenceBoundsStruct::operator !=(
        const SequenceBoundsStruct& x) const
{
    return !(*this == x);
}

size_t SequenceBoundsStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceBoundsStruct_max_cdr_typesize;
}

size_t SequenceBoundsStruct::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const SequenceBoundsStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_sequence, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void SequenceBoundsStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_sequence;

    scdr.end_serialize_type(current_state);
}

void SequenceBoundsStruct::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m_my_sequence;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function copies the value in member my_sequence
 * @param _my_sequence New value to be copied in member my_sequence
 */
void SequenceBoundsStruct::my_sequence(
        const std::vector<int32_t>& _my_sequence)
{
    m_my_sequence = _my_sequence;
}

/*!
 * @brief This function moves the value in member my_sequence
 * @param _my_sequence New value to be moved in member my_sequence
 */
void SequenceBoundsStruct::my_sequence(
        std::vector<int32_t>&& _my_sequence)
{
    m_my_sequence = std::move(_my_sequence);
}

/*!
 * @brief This function returns a constant reference to member my_sequence
 * @return Constant reference to member my_sequence
 */
const std::vector<int32_t>& SequenceBoundsStruct::my_sequence() const
{
    return m_my_sequence;
}

/*!
 * @brief This function returns a reference to member my_sequence
 * @return Reference to member my_sequence
 */
std::vector<int32_t>& SequenceBoundsStruct::my_sequence()
{
    return m_my_sequence;
}


size_t SequenceBoundsStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceBoundsStruct_max_key_cdr_typesize;
}

bool SequenceBoundsStruct::isKeyDefined()
{
    return false;
}

void SequenceBoundsStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

SequenceSequenceStruct::SequenceSequenceStruct()
{

    // Just to register all known types
    registerTypesTypes();
}

SequenceSequenceStruct::~SequenceSequenceStruct()
{
}

SequenceSequenceStruct::SequenceSequenceStruct(
        const SequenceSequenceStruct& x)
{
    m_my_sequence_sequence = x.m_my_sequence_sequence;
}

SequenceSequenceStruct::SequenceSequenceStruct(
        SequenceSequenceStruct&& x) noexcept 
{
    m_my_sequence_sequence = std::move(x.m_my_sequence_sequence);
}

SequenceSequenceStruct& SequenceSequenceStruct::operator =(
        const SequenceSequenceStruct& x)
{

    m_my_sequence_sequence = x.m_my_sequence_sequence;

    return *this;
}

SequenceSequenceStruct& SequenceSequenceStruct::operator =(
        SequenceSequenceStruct&& x) noexcept
{

    m_my_sequence_sequence = std::move(x.m_my_sequence_sequence);

    return *this;
}

bool SequenceSequenceStruct::operator ==(
        const SequenceSequenceStruct& x) const
{

    return (m_my_sequence_sequence == x.m_my_sequence_sequence);
}

bool SequenceSequenceStruct::operator !=(
        const SequenceSequenceStruct& x) const
{
    return !(*this == x);
}

size_t SequenceSequenceStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceSequenceStruct_max_cdr_typesize;
}

size_t SequenceSequenceStruct::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const SequenceSequenceStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_sequence_sequence, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void SequenceSequenceStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_sequence_sequence;

    scdr.end_serialize_type(current_state);
}

void SequenceSequenceStruct::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m_my_sequence_sequence;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function copies the value in member my_sequence_sequence
 * @param _my_sequence_sequence New value to be copied in member my_sequence_sequence
 */
void SequenceSequenceStruct::my_sequence_sequence(
        const std::vector<std::vector<int32_t>>& _my_sequence_sequence)
{
    m_my_sequence_sequence = _my_sequence_sequence;
}

/*!
 * @brief This function moves the value in member my_sequence_sequence
 * @param _my_sequence_sequence New value to be moved in member my_sequence_sequence
 */
void SequenceSequenceStruct::my_sequence_sequence(
        std::vector<std::vector<int32_t>>&& _my_sequence_sequence)
{
    m_my_sequence_sequence = std::move(_my_sequence_sequence);
}

/*!
 * @brief This function returns a constant reference to member my_sequence_sequence
 * @return Constant reference to member my_sequence_sequence
 */
const std::vector<std::vector<int32_t>>& SequenceSequenceStruct::my_sequence_sequence() const
{
    return m_my_sequence_sequence;
}

/*!
 * @brief This function returns a reference to member my_sequence_sequence
 * @return Reference to member my_sequence_sequence
 */
std::vector<std::vector<int32_t>>& SequenceSequenceStruct::my_sequence_sequence()
{
    return m_my_sequence_sequence;
}


size_t SequenceSequenceStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceSequenceStruct_max_key_cdr_typesize;
}

bool SequenceSequenceStruct::isKeyDefined()
{
    return false;
}

void SequenceSequenceStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

SequenceSequenceBoundsStruct::SequenceSequenceBoundsStruct()
{

    // Just to register all known types
    registerTypesTypes();
}

SequenceSequenceBoundsStruct::~SequenceSequenceBoundsStruct()
{
}

SequenceSequenceBoundsStruct::SequenceSequenceBoundsStruct(
        const SequenceSequenceBoundsStruct& x)
{
    m_my_sequence_sequence = x.m_my_sequence_sequence;
}

SequenceSequenceBoundsStruct::SequenceSequenceBoundsStruct(
        SequenceSequenceBoundsStruct&& x) noexcept 
{
    m_my_sequence_sequence = std::move(x.m_my_sequence_sequence);
}

SequenceSequenceBoundsStruct& SequenceSequenceBoundsStruct::operator =(
        const SequenceSequenceBoundsStruct& x)
{

    m_my_sequence_sequence = x.m_my_sequence_sequence;

    return *this;
}

SequenceSequenceBoundsStruct& SequenceSequenceBoundsStruct::operator =(
        SequenceSequenceBoundsStruct&& x) noexcept
{

    m_my_sequence_sequence = std::move(x.m_my_sequence_sequence);

    return *this;
}

bool SequenceSequenceBoundsStruct::operator ==(
        const SequenceSequenceBoundsStruct& x) const
{

    return (m_my_sequence_sequence == x.m_my_sequence_sequence);
}

bool SequenceSequenceBoundsStruct::operator !=(
        const SequenceSequenceBoundsStruct& x) const
{
    return !(*this == x);
}

size_t SequenceSequenceBoundsStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceSequenceBoundsStruct_max_cdr_typesize;
}

size_t SequenceSequenceBoundsStruct::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const SequenceSequenceBoundsStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_sequence_sequence, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void SequenceSequenceBoundsStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_sequence_sequence;

    scdr.end_serialize_type(current_state);
}

void SequenceSequenceBoundsStruct::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m_my_sequence_sequence;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function copies the value in member my_sequence_sequence
 * @param _my_sequence_sequence New value to be copied in member my_sequence_sequence
 */
void SequenceSequenceBoundsStruct::my_sequence_sequence(
        const std::vector<std::vector<int32_t>>& _my_sequence_sequence)
{
    m_my_sequence_sequence = _my_sequence_sequence;
}

/*!
 * @brief This function moves the value in member my_sequence_sequence
 * @param _my_sequence_sequence New value to be moved in member my_sequence_sequence
 */
void SequenceSequenceBoundsStruct::my_sequence_sequence(
        std::vector<std::vector<int32_t>>&& _my_sequence_sequence)
{
    m_my_sequence_sequence = std::move(_my_sequence_sequence);
}

/*!
 * @brief This function returns a constant reference to member my_sequence_sequence
 * @return Constant reference to member my_sequence_sequence
 */
const std::vector<std::vector<int32_t>>& SequenceSequenceBoundsStruct::my_sequence_sequence() const
{
    return m_my_sequence_sequence;
}

/*!
 * @brief This function returns a reference to member my_sequence_sequence
 * @return Reference to member my_sequence_sequence
 */
std::vector<std::vector<int32_t>>& SequenceSequenceBoundsStruct::my_sequence_sequence()
{
    return m_my_sequence_sequence;
}


size_t SequenceSequenceBoundsStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SequenceSequenceBoundsStruct_max_key_cdr_typesize;
}

bool SequenceSequenceBoundsStruct::isKeyDefined()
{
    return false;
}

void SequenceSequenceBoundsStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

MapStruct::MapStruct()
{

    // Just to register all known types
    registerTypesTypes();
}

MapStruct::~MapStruct()
{
}

MapStruct::MapStruct(
        const MapStruct& x)
{
    m_my_map = x.m_my_map;
}

MapStruct::MapStruct(
        MapStruct&& x) noexcept 
{
    m_my_map = std::move(x.m_my_map);
}

MapStruct& MapStruct::operator =(
        const MapStruct& x)
{

    m_my_map = x.m_my_map;

    return *this;
}

MapStruct& MapStruct::operator =(
        MapStruct&& x) noexcept
{

    m_my_map = std::move(x.m_my_map);

    return *this;
}

bool MapStruct::operator ==(
        const MapStruct& x) const
{

    return (m_my_map == x.m_my_map);
}

bool MapStruct::operator !=(
        const MapStruct& x) const
{
    return !(*this == x);
}

size_t MapStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return MapStruct_max_cdr_typesize;
}

size_t MapStruct::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_map, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void MapStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_map;

    scdr.end_serialize_type(current_state);
}

void MapStruct::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m_my_map;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function copies the value in member my_map
 * @param _my_map New value to be copied in member my_map
 */
void MapStruct::my_map(
        const std::map<int32_t, int32_t>& _my_map)
{
    m_my_map = _my_map;
}

/*!
 * @brief This function moves the value in member my_map
 * @param _my_map New value to be moved in member my_map
 */
void MapStruct::my_map(
        std::map<int32_t, int32_t>&& _my_map)
{
    m_my_map = std::move(_my_map);
}

/*!
 * @brief This function returns a constant reference to member my_map
 * @return Constant reference to member my_map
 */
const std::map<int32_t, int32_t>& MapStruct::my_map() const
{
    return m_my_map;
}

/*!
 * @brief This function returns a reference to member my_map
 * @return Reference to member my_map
 */
std::map<int32_t, int32_t>& MapStruct::my_map()
{
    return m_my_map;
}


size_t MapStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return MapStruct_max_key_cdr_typesize;
}

bool MapStruct::isKeyDefined()
{
    return false;
}

void MapStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

MapStructEqual::MapStructEqual()
{

    // Just to register all known types
    registerTypesTypes();
}

MapStructEqual::~MapStructEqual()
{
}

MapStructEqual::MapStructEqual(
        const MapStructEqual& x)
{
    m_my_map_equal = x.m_my_map_equal;
}

MapStructEqual::MapStructEqual(
        MapStructEqual&& x) noexcept 
{
    m_my_map_equal = std::move(x.m_my_map_equal);
}

MapStructEqual& MapStructEqual::operator =(
        const MapStructEqual& x)
{

    m_my_map_equal = x.m_my_map_equal;

    return *this;
}

MapStructEqual& MapStructEqual::operator =(
        MapStructEqual&& x) noexcept
{

    m_my_map_equal = std::move(x.m_my_map_equal);

    return *this;
}

bool MapStructEqual::operator ==(
        const MapStructEqual& x) const
{

    return (m_my_map_equal == x.m_my_map_equal);
}

bool MapStructEqual::operator !=(
        const MapStructEqual& x) const
{
    return !(*this == x);
}

size_t MapStructEqual::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return MapStructEqual_max_cdr_typesize;
}

size_t MapStructEqual::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapStructEqual& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_map_equal, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void MapStructEqual::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_map_equal;

    scdr.end_serialize_type(current_state);
}

void MapStructEqual::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m_my_map_equal;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function copies the value in member my_map_equal
 * @param _my_map_equal New value to be copied in member my_map_equal
 */
void MapStructEqual::my_map_equal(
        const std::map<int32_t, int32_t>& _my_map_equal)
{
    m_my_map_equal = _my_map_equal;
}

/*!
 * @brief This function moves the value in member my_map_equal
 * @param _my_map_equal New value to be moved in member my_map_equal
 */
void MapStructEqual::my_map_equal(
        std::map<int32_t, int32_t>&& _my_map_equal)
{
    m_my_map_equal = std::move(_my_map_equal);
}

/*!
 * @brief This function returns a constant reference to member my_map_equal
 * @return Constant reference to member my_map_equal
 */
const std::map<int32_t, int32_t>& MapStructEqual::my_map_equal() const
{
    return m_my_map_equal;
}

/*!
 * @brief This function returns a reference to member my_map_equal
 * @return Reference to member my_map_equal
 */
std::map<int32_t, int32_t>& MapStructEqual::my_map_equal()
{
    return m_my_map_equal;
}


size_t MapStructEqual::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return MapStructEqual_max_key_cdr_typesize;
}

bool MapStructEqual::isKeyDefined()
{
    return false;
}

void MapStructEqual::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

MapBadKeyStruct::MapBadKeyStruct()
{

    // Just to register all known types
    registerTypesTypes();
}

MapBadKeyStruct::~MapBadKeyStruct()
{
}

MapBadKeyStruct::MapBadKeyStruct(
        const MapBadKeyStruct& x)
{
    m_my_map = x.m_my_map;
}

MapBadKeyStruct::MapBadKeyStruct(
        MapBadKeyStruct&& x) noexcept 
{
    m_my_map = std::move(x.m_my_map);
}

MapBadKeyStruct& MapBadKeyStruct::operator =(
        const MapBadKeyStruct& x)
{

    m_my_map = x.m_my_map;

    return *this;
}

MapBadKeyStruct& MapBadKeyStruct::operator =(
        MapBadKeyStruct&& x) noexcept
{

    m_my_map = std::move(x.m_my_map);

    return *this;
}

bool MapBadKeyStruct::operator ==(
        const MapBadKeyStruct& x) const
{

    return (m_my_map == x.m_my_map);
}

bool MapBadKeyStruct::operator !=(
        const MapBadKeyStruct& x) const
{
    return !(*this == x);
}

size_t MapBadKeyStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return MapBadKeyStruct_max_cdr_typesize;
}

size_t MapBadKeyStruct::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapBadKeyStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_map, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void MapBadKeyStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_map;

    scdr.end_serialize_type(current_state);
}

void MapBadKeyStruct::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m_my_map;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function copies the value in member my_map
 * @param _my_map New value to be copied in member my_map
 */
void MapBadKeyStruct::my_map(
        const std::map<uint8_t, int32_t>& _my_map)
{
    m_my_map = _my_map;
}

/*!
 * @brief This function moves the value in member my_map
 * @param _my_map New value to be moved in member my_map
 */
void MapBadKeyStruct::my_map(
        std::map<uint8_t, int32_t>&& _my_map)
{
    m_my_map = std::move(_my_map);
}

/*!
 * @brief This function returns a constant reference to member my_map
 * @return Constant reference to member my_map
 */
const std::map<uint8_t, int32_t>& MapBadKeyStruct::my_map() const
{
    return m_my_map;
}

/*!
 * @brief This function returns a reference to member my_map
 * @return Reference to member my_map
 */
std::map<uint8_t, int32_t>& MapBadKeyStruct::my_map()
{
    return m_my_map;
}


size_t MapBadKeyStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return MapBadKeyStruct_max_key_cdr_typesize;
}

bool MapBadKeyStruct::isKeyDefined()
{
    return false;
}

void MapBadKeyStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

MapBadElemStruct::MapBadElemStruct()
{

    // Just to register all known types
    registerTypesTypes();
}

MapBadElemStruct::~MapBadElemStruct()
{
}

MapBadElemStruct::MapBadElemStruct(
        const MapBadElemStruct& x)
{
    m_my_map = x.m_my_map;
}

MapBadElemStruct::MapBadElemStruct(
        MapBadElemStruct&& x) noexcept 
{
    m_my_map = std::move(x.m_my_map);
}

MapBadElemStruct& MapBadElemStruct::operator =(
        const MapBadElemStruct& x)
{

    m_my_map = x.m_my_map;

    return *this;
}

MapBadElemStruct& MapBadElemStruct::operator =(
        MapBadElemStruct&& x) noexcept
{

    m_my_map = std::move(x.m_my_map);

    return *this;
}

bool MapBadElemStruct::operator ==(
        const MapBadElemStruct& x) const
{

    return (m_my_map == x.m_my_map);
}

bool MapBadElemStruct::operator !=(
        const MapBadElemStruct& x) const
{
    return !(*this == x);
}

size_t MapBadElemStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return MapBadElemStruct_max_cdr_typesize;
}

size_t MapBadElemStruct::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapBadElemStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_map, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void MapBadElemStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_map;

    scdr.end_serialize_type(current_state);
}

void MapBadElemStruct::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m_my_map;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function copies the value in member my_map
 * @param _my_map New value to be copied in member my_map
 */
void MapBadElemStruct::my_map(
        const std::map<int32_t, int64_t>& _my_map)
{
    m_my_map = _my_map;
}

/*!
 * @brief This function moves the value in member my_map
 * @param _my_map New value to be moved in member my_map
 */
void MapBadElemStruct::my_map(
        std::map<int32_t, int64_t>&& _my_map)
{
    m_my_map = std::move(_my_map);
}

/*!
 * @brief This function returns a constant reference to member my_map
 * @return Constant reference to member my_map
 */
const std::map<int32_t, int64_t>& MapBadElemStruct::my_map() const
{
    return m_my_map;
}

/*!
 * @brief This function returns a reference to member my_map
 * @return Reference to member my_map
 */
std::map<int32_t, int64_t>& MapBadElemStruct::my_map()
{
    return m_my_map;
}


size_t MapBadElemStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return MapBadElemStruct_max_key_cdr_typesize;
}

bool MapBadElemStruct::isKeyDefined()
{
    return false;
}

void MapBadElemStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

MapBoundsStruct::MapBoundsStruct()
{

    // Just to register all known types
    registerTypesTypes();
}

MapBoundsStruct::~MapBoundsStruct()
{
}

MapBoundsStruct::MapBoundsStruct(
        const MapBoundsStruct& x)
{
    m_my_map = x.m_my_map;
}

MapBoundsStruct::MapBoundsStruct(
        MapBoundsStruct&& x) noexcept 
{
    m_my_map = std::move(x.m_my_map);
}

MapBoundsStruct& MapBoundsStruct::operator =(
        const MapBoundsStruct& x)
{

    m_my_map = x.m_my_map;

    return *this;
}

MapBoundsStruct& MapBoundsStruct::operator =(
        MapBoundsStruct&& x) noexcept
{

    m_my_map = std::move(x.m_my_map);

    return *this;
}

bool MapBoundsStruct::operator ==(
        const MapBoundsStruct& x) const
{

    return (m_my_map == x.m_my_map);
}

bool MapBoundsStruct::operator !=(
        const MapBoundsStruct& x) const
{
    return !(*this == x);
}

size_t MapBoundsStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return MapBoundsStruct_max_cdr_typesize;
}

size_t MapBoundsStruct::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapBoundsStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_map, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void MapBoundsStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_map;

    scdr.end_serialize_type(current_state);
}

void MapBoundsStruct::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m_my_map;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function copies the value in member my_map
 * @param _my_map New value to be copied in member my_map
 */
void MapBoundsStruct::my_map(
        const std::map<int32_t, int32_t>& _my_map)
{
    m_my_map = _my_map;
}

/*!
 * @brief This function moves the value in member my_map
 * @param _my_map New value to be moved in member my_map
 */
void MapBoundsStruct::my_map(
        std::map<int32_t, int32_t>&& _my_map)
{
    m_my_map = std::move(_my_map);
}

/*!
 * @brief This function returns a constant reference to member my_map
 * @return Constant reference to member my_map
 */
const std::map<int32_t, int32_t>& MapBoundsStruct::my_map() const
{
    return m_my_map;
}

/*!
 * @brief This function returns a reference to member my_map
 * @return Reference to member my_map
 */
std::map<int32_t, int32_t>& MapBoundsStruct::my_map()
{
    return m_my_map;
}


size_t MapBoundsStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return MapBoundsStruct_max_key_cdr_typesize;
}

bool MapBoundsStruct::isKeyDefined()
{
    return false;
}

void MapBoundsStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

MapMapStruct::MapMapStruct()
{

    // Just to register all known types
    registerTypesTypes();
}

MapMapStruct::~MapMapStruct()
{
}

MapMapStruct::MapMapStruct(
        const MapMapStruct& x)
{
    m_my_map_map = x.m_my_map_map;
}

MapMapStruct::MapMapStruct(
        MapMapStruct&& x) noexcept 
{
    m_my_map_map = std::move(x.m_my_map_map);
}

MapMapStruct& MapMapStruct::operator =(
        const MapMapStruct& x)
{

    m_my_map_map = x.m_my_map_map;

    return *this;
}

MapMapStruct& MapMapStruct::operator =(
        MapMapStruct&& x) noexcept
{

    m_my_map_map = std::move(x.m_my_map_map);

    return *this;
}

bool MapMapStruct::operator ==(
        const MapMapStruct& x) const
{

    return (m_my_map_map == x.m_my_map_map);
}

bool MapMapStruct::operator !=(
        const MapMapStruct& x) const
{
    return !(*this == x);
}

size_t MapMapStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return MapMapStruct_max_cdr_typesize;
}

size_t MapMapStruct::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapMapStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_map_map, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void MapMapStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_map_map;

    scdr.end_serialize_type(current_state);
}

void MapMapStruct::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m_my_map_map;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function copies the value in member my_map_map
 * @param _my_map_map New value to be copied in member my_map_map
 */
void MapMapStruct::my_map_map(
        const std::map<int32_t, std::map<int32_t, int32_t>>& _my_map_map)
{
    m_my_map_map = _my_map_map;
}

/*!
 * @brief This function moves the value in member my_map_map
 * @param _my_map_map New value to be moved in member my_map_map
 */
void MapMapStruct::my_map_map(
        std::map<int32_t, std::map<int32_t, int32_t>>&& _my_map_map)
{
    m_my_map_map = std::move(_my_map_map);
}

/*!
 * @brief This function returns a constant reference to member my_map_map
 * @return Constant reference to member my_map_map
 */
const std::map<int32_t, std::map<int32_t, int32_t>>& MapMapStruct::my_map_map() const
{
    return m_my_map_map;
}

/*!
 * @brief This function returns a reference to member my_map_map
 * @return Reference to member my_map_map
 */
std::map<int32_t, std::map<int32_t, int32_t>>& MapMapStruct::my_map_map()
{
    return m_my_map_map;
}


size_t MapMapStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return MapMapStruct_max_key_cdr_typesize;
}

bool MapMapStruct::isKeyDefined()
{
    return false;
}

void MapMapStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

MapMapBoundsStruct::MapMapBoundsStruct()
{

    // Just to register all known types
    registerTypesTypes();
}

MapMapBoundsStruct::~MapMapBoundsStruct()
{
}

MapMapBoundsStruct::MapMapBoundsStruct(
        const MapMapBoundsStruct& x)
{
    m_my_map_map = x.m_my_map_map;
}

MapMapBoundsStruct::MapMapBoundsStruct(
        MapMapBoundsStruct&& x) noexcept 
{
    m_my_map_map = std::move(x.m_my_map_map);
}

MapMapBoundsStruct& MapMapBoundsStruct::operator =(
        const MapMapBoundsStruct& x)
{

    m_my_map_map = x.m_my_map_map;

    return *this;
}

MapMapBoundsStruct& MapMapBoundsStruct::operator =(
        MapMapBoundsStruct&& x) noexcept
{

    m_my_map_map = std::move(x.m_my_map_map);

    return *this;
}

bool MapMapBoundsStruct::operator ==(
        const MapMapBoundsStruct& x) const
{

    return (m_my_map_map == x.m_my_map_map);
}

bool MapMapBoundsStruct::operator !=(
        const MapMapBoundsStruct& x) const
{
    return !(*this == x);
}

size_t MapMapBoundsStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return MapMapBoundsStruct_max_cdr_typesize;
}

size_t MapMapBoundsStruct::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const MapMapBoundsStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_map_map, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void MapMapBoundsStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_map_map;

    scdr.end_serialize_type(current_state);
}

void MapMapBoundsStruct::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m_my_map_map;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function copies the value in member my_map_map
 * @param _my_map_map New value to be copied in member my_map_map
 */
void MapMapBoundsStruct::my_map_map(
        const std::map<int32_t, std::map<int32_t, int32_t>>& _my_map_map)
{
    m_my_map_map = _my_map_map;
}

/*!
 * @brief This function moves the value in member my_map_map
 * @param _my_map_map New value to be moved in member my_map_map
 */
void MapMapBoundsStruct::my_map_map(
        std::map<int32_t, std::map<int32_t, int32_t>>&& _my_map_map)
{
    m_my_map_map = std::move(_my_map_map);
}

/*!
 * @brief This function returns a constant reference to member my_map_map
 * @return Constant reference to member my_map_map
 */
const std::map<int32_t, std::map<int32_t, int32_t>>& MapMapBoundsStruct::my_map_map() const
{
    return m_my_map_map;
}

/*!
 * @brief This function returns a reference to member my_map_map
 * @return Reference to member my_map_map
 */
std::map<int32_t, std::map<int32_t, int32_t>>& MapMapBoundsStruct::my_map_map()
{
    return m_my_map_map;
}


size_t MapMapBoundsStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return MapMapBoundsStruct_max_key_cdr_typesize;
}

bool MapMapBoundsStruct::isKeyDefined()
{
    return false;
}

void MapMapBoundsStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

SimpleUnion::SimpleUnion()
{
    m__d = A;


}

SimpleUnion::~SimpleUnion()
{
}

SimpleUnion::SimpleUnion(
        const SimpleUnion& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case A:
        m_first = x.m_first;
        break;
        case B:
        m_second = x.m_second;
        break;
        default:
        break;
    }
}

SimpleUnion::SimpleUnion(
        SimpleUnion&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case A:
        m_first = x.m_first;
        break;
        case B:
        m_second = x.m_second;
        break;
        default:
        break;
    }
}

SimpleUnion& SimpleUnion::operator =(
        const SimpleUnion& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case A:
        m_first = x.m_first;
        break;
        case B:
        m_second = x.m_second;
        break;
        default:
        break;
    }

    return *this;
}

SimpleUnion& SimpleUnion::operator =(
        SimpleUnion&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case A:
        m_first = x.m_first;
        break;
        case B:
        m_second = x.m_second;
        break;
        default:
        break;
    }

    return *this;
}

bool SimpleUnion::operator ==(
        const SimpleUnion& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case A:
            return (m_first == x.m_first);
            break;
        case B:
            return (m_second == x.m_second);
            break;
        default:
        break;
    }
    return false;
}

bool SimpleUnion::operator !=(
        const SimpleUnion& x) const
{
    return !(*this == x);
}

void SimpleUnion::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case A:
        switch(__d)
        {
            case A:
            b = true;
            break;
            default:
            break;
        }
        break;
        case B:
        switch(__d)
        {
            case B:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t SimpleUnion::_d() const
{
    return m__d;
}

int32_t& SimpleUnion::_d()
{
    return m__d;
}

void SimpleUnion::first(
        int32_t _first)
{
    m_first = _first;
    m__d = A;
}

int32_t SimpleUnion::first() const
{
    bool b = false;

    switch(m__d)
    {
        case A:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_first;
}

int32_t& SimpleUnion::first()
{
    bool b = false;

    switch(m__d)
    {
        case A:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_first;
}
void SimpleUnion::second(
        int64_t _second)
{
    m_second = _second;
    m__d = B;
}

int64_t SimpleUnion::second() const
{
    bool b = false;

    switch(m__d)
    {
        case B:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_second;
}

int64_t& SimpleUnion::second()
{
    bool b = false;

    switch(m__d)
    {
        case B:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_second;
}

size_t SimpleUnion::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const SimpleUnion& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);

    // TODO Member id del discriminador
    current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m__d,
            current_alignment);

    switch(data.m__d)
    {
                        case A:
                        current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                                data.m_first, current_alignment);
                        break;
                
                        case B:
                        current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                                data.m_second, current_alignment);
                        break;
                
            default:
                break;
    }

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void SimpleUnion::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m__d;

    switch(m__d)
    {
        case A:
        scdr << eprosima::fastcdr::MemberId(1) << m_first;
        break;
        case B:
        scdr << eprosima::fastcdr::MemberId(2) << m_second;
        break;
        default:
        break;
    }

    scdr.end_serialize_type(current_state);
}

void SimpleUnion::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m__d;
                        break;
                                        case 1:
                                            dcdr >> m_first;
                                            ret_value = false;
                                            break;
                                        
                                        case 2:
                                            dcdr >> m_second;
                                            ret_value = false;
                                            break;
                                        
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}


SimpleUnionNames::SimpleUnionNames()
{
    m__d = A;


}

SimpleUnionNames::~SimpleUnionNames()
{
}

SimpleUnionNames::SimpleUnionNames(
        const SimpleUnionNames& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case A:
        m_first_case = x.m_first_case;
        break;
        case B:
        m_second_case = x.m_second_case;
        break;
        default:
        break;
    }
}

SimpleUnionNames::SimpleUnionNames(
        SimpleUnionNames&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case A:
        m_first_case = x.m_first_case;
        break;
        case B:
        m_second_case = x.m_second_case;
        break;
        default:
        break;
    }
}

SimpleUnionNames& SimpleUnionNames::operator =(
        const SimpleUnionNames& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case A:
        m_first_case = x.m_first_case;
        break;
        case B:
        m_second_case = x.m_second_case;
        break;
        default:
        break;
    }

    return *this;
}

SimpleUnionNames& SimpleUnionNames::operator =(
        SimpleUnionNames&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case A:
        m_first_case = x.m_first_case;
        break;
        case B:
        m_second_case = x.m_second_case;
        break;
        default:
        break;
    }

    return *this;
}

bool SimpleUnionNames::operator ==(
        const SimpleUnionNames& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case A:
            return (m_first_case == x.m_first_case);
            break;
        case B:
            return (m_second_case == x.m_second_case);
            break;
        default:
        break;
    }
    return false;
}

bool SimpleUnionNames::operator !=(
        const SimpleUnionNames& x) const
{
    return !(*this == x);
}

void SimpleUnionNames::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case A:
        switch(__d)
        {
            case A:
            b = true;
            break;
            default:
            break;
        }
        break;
        case B:
        switch(__d)
        {
            case B:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t SimpleUnionNames::_d() const
{
    return m__d;
}

int32_t& SimpleUnionNames::_d()
{
    return m__d;
}

void SimpleUnionNames::first_case(
        int32_t _first_case)
{
    m_first_case = _first_case;
    m__d = A;
}

int32_t SimpleUnionNames::first_case() const
{
    bool b = false;

    switch(m__d)
    {
        case A:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_first_case;
}

int32_t& SimpleUnionNames::first_case()
{
    bool b = false;

    switch(m__d)
    {
        case A:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_first_case;
}
void SimpleUnionNames::second_case(
        int64_t _second_case)
{
    m_second_case = _second_case;
    m__d = B;
}

int64_t SimpleUnionNames::second_case() const
{
    bool b = false;

    switch(m__d)
    {
        case B:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_second_case;
}

int64_t& SimpleUnionNames::second_case()
{
    bool b = false;

    switch(m__d)
    {
        case B:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_second_case;
}

size_t SimpleUnionNames::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const SimpleUnionNames& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);

    // TODO Member id del discriminador
    current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m__d,
            current_alignment);

    switch(data.m__d)
    {
                        case A:
                        current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                                data.m_first_case, current_alignment);
                        break;
                
                        case B:
                        current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                                data.m_second_case, current_alignment);
                        break;
                
            default:
                break;
    }

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void SimpleUnionNames::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m__d;

    switch(m__d)
    {
        case A:
        scdr << eprosima::fastcdr::MemberId(1) << m_first_case;
        break;
        case B:
        scdr << eprosima::fastcdr::MemberId(2) << m_second_case;
        break;
        default:
        break;
    }

    scdr.end_serialize_type(current_state);
}

void SimpleUnionNames::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m__d;
                        break;
                                        case 1:
                                            dcdr >> m_first_case;
                                            ret_value = false;
                                            break;
                                        
                                        case 2:
                                            dcdr >> m_second_case;
                                            ret_value = false;
                                            break;
                                        
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}


SimpleTypeUnion::SimpleTypeUnion()
{
    m__d = A;


}

SimpleTypeUnion::~SimpleTypeUnion()
{
}

SimpleTypeUnion::SimpleTypeUnion(
        const SimpleTypeUnion& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case A:
        m_first = x.m_first;
        break;
        case B:
        m_second = x.m_second;
        break;
        default:
        break;
    }
}

SimpleTypeUnion::SimpleTypeUnion(
        SimpleTypeUnion&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case A:
        m_first = x.m_first;
        break;
        case B:
        m_second = x.m_second;
        break;
        default:
        break;
    }
}

SimpleTypeUnion& SimpleTypeUnion::operator =(
        const SimpleTypeUnion& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case A:
        m_first = x.m_first;
        break;
        case B:
        m_second = x.m_second;
        break;
        default:
        break;
    }

    return *this;
}

SimpleTypeUnion& SimpleTypeUnion::operator =(
        SimpleTypeUnion&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case A:
        m_first = x.m_first;
        break;
        case B:
        m_second = x.m_second;
        break;
        default:
        break;
    }

    return *this;
}

bool SimpleTypeUnion::operator ==(
        const SimpleTypeUnion& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case A:
            return (m_first == x.m_first);
            break;
        case B:
            return (m_second == x.m_second);
            break;
        default:
        break;
    }
    return false;
}

bool SimpleTypeUnion::operator !=(
        const SimpleTypeUnion& x) const
{
    return !(*this == x);
}

void SimpleTypeUnion::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case A:
        switch(__d)
        {
            case A:
            b = true;
            break;
            default:
            break;
        }
        break;
        case B:
        switch(__d)
        {
            case B:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t SimpleTypeUnion::_d() const
{
    return m__d;
}

int32_t& SimpleTypeUnion::_d()
{
    return m__d;
}

void SimpleTypeUnion::first(
        uint8_t _first)
{
    m_first = _first;
    m__d = A;
}

uint8_t SimpleTypeUnion::first() const
{
    bool b = false;

    switch(m__d)
    {
        case A:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_first;
}

uint8_t& SimpleTypeUnion::first()
{
    bool b = false;

    switch(m__d)
    {
        case A:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_first;
}
void SimpleTypeUnion::second(
        int64_t _second)
{
    m_second = _second;
    m__d = B;
}

int64_t SimpleTypeUnion::second() const
{
    bool b = false;

    switch(m__d)
    {
        case B:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_second;
}

int64_t& SimpleTypeUnion::second()
{
    bool b = false;

    switch(m__d)
    {
        case B:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_second;
}

size_t SimpleTypeUnion::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const SimpleTypeUnion& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);

    // TODO Member id del discriminador
    current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m__d,
            current_alignment);

    switch(data.m__d)
    {
                        case A:
                        current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                                data.m_first, current_alignment);
                        break;
                
                        case B:
                        current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                                data.m_second, current_alignment);
                        break;
                
            default:
                break;
    }

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void SimpleTypeUnion::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m__d;

    switch(m__d)
    {
        case A:
        scdr << eprosima::fastcdr::MemberId(1) << m_first;
        break;
        case B:
        scdr << eprosima::fastcdr::MemberId(2) << m_second;
        break;
        default:
        break;
    }

    scdr.end_serialize_type(current_state);
}

void SimpleTypeUnion::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m__d;
                        break;
                                        case 1:
                                            dcdr >> m_first;
                                            ret_value = false;
                                            break;
                                        
                                        case 2:
                                            dcdr >> m_second;
                                            ret_value = false;
                                            break;
                                        
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}


SimpleBadUnion::SimpleBadUnion()
{
    m__d = A;


}

SimpleBadUnion::~SimpleBadUnion()
{
}

SimpleBadUnion::SimpleBadUnion(
        const SimpleBadUnion& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case A:
        m_first = x.m_first;
        break;
        case C:
        m_second = x.m_second;
        break;
        default:
        break;
    }
}

SimpleBadUnion::SimpleBadUnion(
        SimpleBadUnion&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case A:
        m_first = x.m_first;
        break;
        case C:
        m_second = x.m_second;
        break;
        default:
        break;
    }
}

SimpleBadUnion& SimpleBadUnion::operator =(
        const SimpleBadUnion& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case A:
        m_first = x.m_first;
        break;
        case C:
        m_second = x.m_second;
        break;
        default:
        break;
    }

    return *this;
}

SimpleBadUnion& SimpleBadUnion::operator =(
        SimpleBadUnion&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case A:
        m_first = x.m_first;
        break;
        case C:
        m_second = x.m_second;
        break;
        default:
        break;
    }

    return *this;
}

bool SimpleBadUnion::operator ==(
        const SimpleBadUnion& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case A:
            return (m_first == x.m_first);
            break;
        case C:
            return (m_second == x.m_second);
            break;
        default:
        break;
    }
    return false;
}

bool SimpleBadUnion::operator !=(
        const SimpleBadUnion& x) const
{
    return !(*this == x);
}

void SimpleBadUnion::_d(
        int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case A:
        switch(__d)
        {
            case A:
            b = true;
            break;
            default:
            break;
        }
        break;
        case C:
        switch(__d)
        {
            case C:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t SimpleBadUnion::_d() const
{
    return m__d;
}

int32_t& SimpleBadUnion::_d()
{
    return m__d;
}

void SimpleBadUnion::first(
        int32_t _first)
{
    m_first = _first;
    m__d = A;
}

int32_t SimpleBadUnion::first() const
{
    bool b = false;

    switch(m__d)
    {
        case A:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_first;
}

int32_t& SimpleBadUnion::first()
{
    bool b = false;

    switch(m__d)
    {
        case A:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_first;
}
void SimpleBadUnion::second(
        int64_t _second)
{
    m_second = _second;
    m__d = C;
}

int64_t SimpleBadUnion::second() const
{
    bool b = false;

    switch(m__d)
    {
        case C:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_second;
}

int64_t& SimpleBadUnion::second()
{
    bool b = false;

    switch(m__d)
    {
        case C:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_second;
}

size_t SimpleBadUnion::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const SimpleBadUnion& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);

    // TODO Member id del discriminador
    current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m__d,
            current_alignment);

    switch(data.m__d)
    {
                        case A:
                        current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                                data.m_first, current_alignment);
                        break;
                
                        case C:
                        current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                                data.m_second, current_alignment);
                        break;
                
            default:
                break;
    }

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void SimpleBadUnion::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m__d;

    switch(m__d)
    {
        case A:
        scdr << eprosima::fastcdr::MemberId(1) << m_first;
        break;
        case C:
        scdr << eprosima::fastcdr::MemberId(2) << m_second;
        break;
        default:
        break;
    }

    scdr.end_serialize_type(current_state);
}

void SimpleBadUnion::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m__d;
                        break;
                                        case 1:
                                            dcdr >> m_first;
                                            ret_value = false;
                                            break;
                                        
                                        case 2:
                                            dcdr >> m_second;
                                            ret_value = false;
                                            break;
                                        
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}


SimpleBadDiscUnion::SimpleBadDiscUnion()
{
    m__d = 0;


}

SimpleBadDiscUnion::~SimpleBadDiscUnion()
{
}

SimpleBadDiscUnion::SimpleBadDiscUnion(
        const SimpleBadDiscUnion& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 0:
        m_first = x.m_first;
        break;
        case 1:
        m_second = x.m_second;
        break;
        default:
        break;
    }
}

SimpleBadDiscUnion::SimpleBadDiscUnion(
        SimpleBadDiscUnion&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 0:
        m_first = x.m_first;
        break;
        case 1:
        m_second = x.m_second;
        break;
        default:
        break;
    }
}

SimpleBadDiscUnion& SimpleBadDiscUnion::operator =(
        const SimpleBadDiscUnion& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 0:
        m_first = x.m_first;
        break;
        case 1:
        m_second = x.m_second;
        break;
        default:
        break;
    }

    return *this;
}

SimpleBadDiscUnion& SimpleBadDiscUnion::operator =(
        SimpleBadDiscUnion&& x) noexcept
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 0:
        m_first = x.m_first;
        break;
        case 1:
        m_second = x.m_second;
        break;
        default:
        break;
    }

    return *this;
}

bool SimpleBadDiscUnion::operator ==(
        const SimpleBadDiscUnion& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch(m__d)
    {
        case 0:
            return (m_first == x.m_first);
            break;
        case 1:
            return (m_second == x.m_second);
            break;
        default:
        break;
    }
    return false;
}

bool SimpleBadDiscUnion::operator !=(
        const SimpleBadDiscUnion& x) const
{
    return !(*this == x);
}

void SimpleBadDiscUnion::_d(
        uint8_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 0:
        switch(__d)
        {
            case 0:
            b = true;
            break;
            default:
            break;
        }
        break;
        case 1:
        switch(__d)
        {
            case 1:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

uint8_t SimpleBadDiscUnion::_d() const
{
    return m__d;
}

uint8_t& SimpleBadDiscUnion::_d()
{
    return m__d;
}

void SimpleBadDiscUnion::first(
        int32_t _first)
{
    m_first = _first;
    m__d = 0;
}

int32_t SimpleBadDiscUnion::first() const
{
    bool b = false;

    switch(m__d)
    {
        case 0:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_first;
}

int32_t& SimpleBadDiscUnion::first()
{
    bool b = false;

    switch(m__d)
    {
        case 0:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_first;
}
void SimpleBadDiscUnion::second(
        int64_t _second)
{
    m_second = _second;
    m__d = 1;
}

int64_t SimpleBadDiscUnion::second() const
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_second;
}

int64_t& SimpleBadDiscUnion::second()
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_second;
}

size_t SimpleBadDiscUnion::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const SimpleBadDiscUnion& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);

    // TODO Member id del discriminador
    current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m__d,
            current_alignment);

    switch(data.m__d)
    {
                        case 0:
                        current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                                data.m_first, current_alignment);
                        break;
                
                        case 1:
                        current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                                data.m_second, current_alignment);
                        break;
                
            default:
                break;
    }

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void SimpleBadDiscUnion::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m__d;

    switch(m__d)
    {
        case 0:
        scdr << eprosima::fastcdr::MemberId(1) << m_first;
        break;
        case 1:
        scdr << eprosima::fastcdr::MemberId(2) << m_second;
        break;
        default:
        break;
    }

    scdr.end_serialize_type(current_state);
}

void SimpleBadDiscUnion::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m__d;
                        break;
                                        case 1:
                                            dcdr >> m_first;
                                            ret_value = false;
                                            break;
                                        
                                        case 2:
                                            dcdr >> m_second;
                                            ret_value = false;
                                            break;
                                        
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}


SimpleUnionStruct::SimpleUnionStruct()
{

    // Just to register all known types
    registerTypesTypes();
}

SimpleUnionStruct::~SimpleUnionStruct()
{
}

SimpleUnionStruct::SimpleUnionStruct(
        const SimpleUnionStruct& x)
{
    m_my_union = x.m_my_union;
}

SimpleUnionStruct::SimpleUnionStruct(
        SimpleUnionStruct&& x) noexcept 
{
    m_my_union = std::move(x.m_my_union);
}

SimpleUnionStruct& SimpleUnionStruct::operator =(
        const SimpleUnionStruct& x)
{

    m_my_union = x.m_my_union;

    return *this;
}

SimpleUnionStruct& SimpleUnionStruct::operator =(
        SimpleUnionStruct&& x) noexcept
{

    m_my_union = std::move(x.m_my_union);

    return *this;
}

bool SimpleUnionStruct::operator ==(
        const SimpleUnionStruct& x) const
{

    return (m_my_union == x.m_my_union);
}

bool SimpleUnionStruct::operator !=(
        const SimpleUnionStruct& x) const
{
    return !(*this == x);
}

size_t SimpleUnionStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SimpleUnionStruct_max_cdr_typesize;
}

size_t SimpleUnionStruct::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const SimpleUnionStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_union, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void SimpleUnionStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_union;

    scdr.end_serialize_type(current_state);
}

void SimpleUnionStruct::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m_my_union;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function copies the value in member my_union
 * @param _my_union New value to be copied in member my_union
 */
void SimpleUnionStruct::my_union(
        const SimpleUnion& _my_union)
{
    m_my_union = _my_union;
}

/*!
 * @brief This function moves the value in member my_union
 * @param _my_union New value to be moved in member my_union
 */
void SimpleUnionStruct::my_union(
        SimpleUnion&& _my_union)
{
    m_my_union = std::move(_my_union);
}

/*!
 * @brief This function returns a constant reference to member my_union
 * @return Constant reference to member my_union
 */
const SimpleUnion& SimpleUnionStruct::my_union() const
{
    return m_my_union;
}

/*!
 * @brief This function returns a reference to member my_union
 * @return Reference to member my_union
 */
SimpleUnion& SimpleUnionStruct::my_union()
{
    return m_my_union;
}


size_t SimpleUnionStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SimpleUnionStruct_max_key_cdr_typesize;
}

bool SimpleUnionStruct::isKeyDefined()
{
    return false;
}

void SimpleUnionStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

SimpleUnionStructEqual::SimpleUnionStructEqual()
{

    // Just to register all known types
    registerTypesTypes();
}

SimpleUnionStructEqual::~SimpleUnionStructEqual()
{
}

SimpleUnionStructEqual::SimpleUnionStructEqual(
        const SimpleUnionStructEqual& x)
{
    m_my_union_equal = x.m_my_union_equal;
}

SimpleUnionStructEqual::SimpleUnionStructEqual(
        SimpleUnionStructEqual&& x) noexcept 
{
    m_my_union_equal = std::move(x.m_my_union_equal);
}

SimpleUnionStructEqual& SimpleUnionStructEqual::operator =(
        const SimpleUnionStructEqual& x)
{

    m_my_union_equal = x.m_my_union_equal;

    return *this;
}

SimpleUnionStructEqual& SimpleUnionStructEqual::operator =(
        SimpleUnionStructEqual&& x) noexcept
{

    m_my_union_equal = std::move(x.m_my_union_equal);

    return *this;
}

bool SimpleUnionStructEqual::operator ==(
        const SimpleUnionStructEqual& x) const
{

    return (m_my_union_equal == x.m_my_union_equal);
}

bool SimpleUnionStructEqual::operator !=(
        const SimpleUnionStructEqual& x) const
{
    return !(*this == x);
}

size_t SimpleUnionStructEqual::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SimpleUnionStructEqual_max_cdr_typesize;
}

size_t SimpleUnionStructEqual::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const SimpleUnionStructEqual& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_union_equal, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void SimpleUnionStructEqual::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_union_equal;

    scdr.end_serialize_type(current_state);
}

void SimpleUnionStructEqual::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m_my_union_equal;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function copies the value in member my_union_equal
 * @param _my_union_equal New value to be copied in member my_union_equal
 */
void SimpleUnionStructEqual::my_union_equal(
        const SimpleUnion& _my_union_equal)
{
    m_my_union_equal = _my_union_equal;
}

/*!
 * @brief This function moves the value in member my_union_equal
 * @param _my_union_equal New value to be moved in member my_union_equal
 */
void SimpleUnionStructEqual::my_union_equal(
        SimpleUnion&& _my_union_equal)
{
    m_my_union_equal = std::move(_my_union_equal);
}

/*!
 * @brief This function returns a constant reference to member my_union_equal
 * @return Constant reference to member my_union_equal
 */
const SimpleUnion& SimpleUnionStructEqual::my_union_equal() const
{
    return m_my_union_equal;
}

/*!
 * @brief This function returns a reference to member my_union_equal
 * @return Reference to member my_union_equal
 */
SimpleUnion& SimpleUnionStructEqual::my_union_equal()
{
    return m_my_union_equal;
}


size_t SimpleUnionStructEqual::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SimpleUnionStructEqual_max_key_cdr_typesize;
}

bool SimpleUnionStructEqual::isKeyDefined()
{
    return false;
}

void SimpleUnionStructEqual::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

SimpleUnionNamesStruct::SimpleUnionNamesStruct()
{

    // Just to register all known types
    registerTypesTypes();
}

SimpleUnionNamesStruct::~SimpleUnionNamesStruct()
{
}

SimpleUnionNamesStruct::SimpleUnionNamesStruct(
        const SimpleUnionNamesStruct& x)
{
    m_my_union = x.m_my_union;
}

SimpleUnionNamesStruct::SimpleUnionNamesStruct(
        SimpleUnionNamesStruct&& x) noexcept 
{
    m_my_union = std::move(x.m_my_union);
}

SimpleUnionNamesStruct& SimpleUnionNamesStruct::operator =(
        const SimpleUnionNamesStruct& x)
{

    m_my_union = x.m_my_union;

    return *this;
}

SimpleUnionNamesStruct& SimpleUnionNamesStruct::operator =(
        SimpleUnionNamesStruct&& x) noexcept
{

    m_my_union = std::move(x.m_my_union);

    return *this;
}

bool SimpleUnionNamesStruct::operator ==(
        const SimpleUnionNamesStruct& x) const
{

    return (m_my_union == x.m_my_union);
}

bool SimpleUnionNamesStruct::operator !=(
        const SimpleUnionNamesStruct& x) const
{
    return !(*this == x);
}

size_t SimpleUnionNamesStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SimpleUnionNamesStruct_max_cdr_typesize;
}

size_t SimpleUnionNamesStruct::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const SimpleUnionNamesStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_union, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void SimpleUnionNamesStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_union;

    scdr.end_serialize_type(current_state);
}

void SimpleUnionNamesStruct::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m_my_union;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function copies the value in member my_union
 * @param _my_union New value to be copied in member my_union
 */
void SimpleUnionNamesStruct::my_union(
        const SimpleUnionNames& _my_union)
{
    m_my_union = _my_union;
}

/*!
 * @brief This function moves the value in member my_union
 * @param _my_union New value to be moved in member my_union
 */
void SimpleUnionNamesStruct::my_union(
        SimpleUnionNames&& _my_union)
{
    m_my_union = std::move(_my_union);
}

/*!
 * @brief This function returns a constant reference to member my_union
 * @return Constant reference to member my_union
 */
const SimpleUnionNames& SimpleUnionNamesStruct::my_union() const
{
    return m_my_union;
}

/*!
 * @brief This function returns a reference to member my_union
 * @return Reference to member my_union
 */
SimpleUnionNames& SimpleUnionNamesStruct::my_union()
{
    return m_my_union;
}


size_t SimpleUnionNamesStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SimpleUnionNamesStruct_max_key_cdr_typesize;
}

bool SimpleUnionNamesStruct::isKeyDefined()
{
    return false;
}

void SimpleUnionNamesStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

SimpleTypeUnionStruct::SimpleTypeUnionStruct()
{

    // Just to register all known types
    registerTypesTypes();
}

SimpleTypeUnionStruct::~SimpleTypeUnionStruct()
{
}

SimpleTypeUnionStruct::SimpleTypeUnionStruct(
        const SimpleTypeUnionStruct& x)
{
    m_my_union = x.m_my_union;
}

SimpleTypeUnionStruct::SimpleTypeUnionStruct(
        SimpleTypeUnionStruct&& x) noexcept 
{
    m_my_union = std::move(x.m_my_union);
}

SimpleTypeUnionStruct& SimpleTypeUnionStruct::operator =(
        const SimpleTypeUnionStruct& x)
{

    m_my_union = x.m_my_union;

    return *this;
}

SimpleTypeUnionStruct& SimpleTypeUnionStruct::operator =(
        SimpleTypeUnionStruct&& x) noexcept
{

    m_my_union = std::move(x.m_my_union);

    return *this;
}

bool SimpleTypeUnionStruct::operator ==(
        const SimpleTypeUnionStruct& x) const
{

    return (m_my_union == x.m_my_union);
}

bool SimpleTypeUnionStruct::operator !=(
        const SimpleTypeUnionStruct& x) const
{
    return !(*this == x);
}

size_t SimpleTypeUnionStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SimpleTypeUnionStruct_max_cdr_typesize;
}

size_t SimpleTypeUnionStruct::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const SimpleTypeUnionStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_union, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void SimpleTypeUnionStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_union;

    scdr.end_serialize_type(current_state);
}

void SimpleTypeUnionStruct::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m_my_union;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function copies the value in member my_union
 * @param _my_union New value to be copied in member my_union
 */
void SimpleTypeUnionStruct::my_union(
        const SimpleTypeUnion& _my_union)
{
    m_my_union = _my_union;
}

/*!
 * @brief This function moves the value in member my_union
 * @param _my_union New value to be moved in member my_union
 */
void SimpleTypeUnionStruct::my_union(
        SimpleTypeUnion&& _my_union)
{
    m_my_union = std::move(_my_union);
}

/*!
 * @brief This function returns a constant reference to member my_union
 * @return Constant reference to member my_union
 */
const SimpleTypeUnion& SimpleTypeUnionStruct::my_union() const
{
    return m_my_union;
}

/*!
 * @brief This function returns a reference to member my_union
 * @return Reference to member my_union
 */
SimpleTypeUnion& SimpleTypeUnionStruct::my_union()
{
    return m_my_union;
}


size_t SimpleTypeUnionStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SimpleTypeUnionStruct_max_key_cdr_typesize;
}

bool SimpleTypeUnionStruct::isKeyDefined()
{
    return false;
}

void SimpleTypeUnionStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

SimpleBadUnionStruct::SimpleBadUnionStruct()
{

    // Just to register all known types
    registerTypesTypes();
}

SimpleBadUnionStruct::~SimpleBadUnionStruct()
{
}

SimpleBadUnionStruct::SimpleBadUnionStruct(
        const SimpleBadUnionStruct& x)
{
    m_my_union = x.m_my_union;
}

SimpleBadUnionStruct::SimpleBadUnionStruct(
        SimpleBadUnionStruct&& x) noexcept 
{
    m_my_union = std::move(x.m_my_union);
}

SimpleBadUnionStruct& SimpleBadUnionStruct::operator =(
        const SimpleBadUnionStruct& x)
{

    m_my_union = x.m_my_union;

    return *this;
}

SimpleBadUnionStruct& SimpleBadUnionStruct::operator =(
        SimpleBadUnionStruct&& x) noexcept
{

    m_my_union = std::move(x.m_my_union);

    return *this;
}

bool SimpleBadUnionStruct::operator ==(
        const SimpleBadUnionStruct& x) const
{

    return (m_my_union == x.m_my_union);
}

bool SimpleBadUnionStruct::operator !=(
        const SimpleBadUnionStruct& x) const
{
    return !(*this == x);
}

size_t SimpleBadUnionStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SimpleBadUnionStruct_max_cdr_typesize;
}

size_t SimpleBadUnionStruct::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const SimpleBadUnionStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_union, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void SimpleBadUnionStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_union;

    scdr.end_serialize_type(current_state);
}

void SimpleBadUnionStruct::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m_my_union;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function copies the value in member my_union
 * @param _my_union New value to be copied in member my_union
 */
void SimpleBadUnionStruct::my_union(
        const SimpleBadUnion& _my_union)
{
    m_my_union = _my_union;
}

/*!
 * @brief This function moves the value in member my_union
 * @param _my_union New value to be moved in member my_union
 */
void SimpleBadUnionStruct::my_union(
        SimpleBadUnion&& _my_union)
{
    m_my_union = std::move(_my_union);
}

/*!
 * @brief This function returns a constant reference to member my_union
 * @return Constant reference to member my_union
 */
const SimpleBadUnion& SimpleBadUnionStruct::my_union() const
{
    return m_my_union;
}

/*!
 * @brief This function returns a reference to member my_union
 * @return Reference to member my_union
 */
SimpleBadUnion& SimpleBadUnionStruct::my_union()
{
    return m_my_union;
}


size_t SimpleBadUnionStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SimpleBadUnionStruct_max_key_cdr_typesize;
}

bool SimpleBadUnionStruct::isKeyDefined()
{
    return false;
}

void SimpleBadUnionStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

SimplBadDiscUnionStruct::SimplBadDiscUnionStruct()
{

    // Just to register all known types
    registerTypesTypes();
}

SimplBadDiscUnionStruct::~SimplBadDiscUnionStruct()
{
}

SimplBadDiscUnionStruct::SimplBadDiscUnionStruct(
        const SimplBadDiscUnionStruct& x)
{
    m_my_union = x.m_my_union;
}

SimplBadDiscUnionStruct::SimplBadDiscUnionStruct(
        SimplBadDiscUnionStruct&& x) noexcept 
{
    m_my_union = std::move(x.m_my_union);
}

SimplBadDiscUnionStruct& SimplBadDiscUnionStruct::operator =(
        const SimplBadDiscUnionStruct& x)
{

    m_my_union = x.m_my_union;

    return *this;
}

SimplBadDiscUnionStruct& SimplBadDiscUnionStruct::operator =(
        SimplBadDiscUnionStruct&& x) noexcept
{

    m_my_union = std::move(x.m_my_union);

    return *this;
}

bool SimplBadDiscUnionStruct::operator ==(
        const SimplBadDiscUnionStruct& x) const
{

    return (m_my_union == x.m_my_union);
}

bool SimplBadDiscUnionStruct::operator !=(
        const SimplBadDiscUnionStruct& x) const
{
    return !(*this == x);
}

size_t SimplBadDiscUnionStruct::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SimplBadDiscUnionStruct_max_cdr_typesize;
}

size_t SimplBadDiscUnionStruct::calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const SimplBadDiscUnionStruct& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    current_alignment += calculator.begin_calculate_type_serialized_size(
            eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            current_alignment);


                current_alignment += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data.m_my_union, current_alignment);

    current_alignment += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return current_alignment - initial_alignment;
}

void SimplBadDiscUnionStruct::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
);

    scdr << eprosima::fastcdr::MemberId(0) << m_my_union;

    scdr.end_serialize_type(current_state);
}

void SimplBadDiscUnionStruct::deserialize(
        eprosima::fastcdr::Cdr& cdr)
{
    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2
 :
eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
,
            [this](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> m_my_union;
ret_value = false;
                        break;
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

/*!
 * @brief This function copies the value in member my_union
 * @param _my_union New value to be copied in member my_union
 */
void SimplBadDiscUnionStruct::my_union(
        const SimpleBadDiscUnion& _my_union)
{
    m_my_union = _my_union;
}

/*!
 * @brief This function moves the value in member my_union
 * @param _my_union New value to be moved in member my_union
 */
void SimplBadDiscUnionStruct::my_union(
        SimpleBadDiscUnion&& _my_union)
{
    m_my_union = std::move(_my_union);
}

/*!
 * @brief This function returns a constant reference to member my_union
 * @return Constant reference to member my_union
 */
const SimpleBadDiscUnion& SimplBadDiscUnionStruct::my_union() const
{
    return m_my_union;
}

/*!
 * @brief This function returns a reference to member my_union
 * @return Reference to member my_union
 */
SimpleBadDiscUnion& SimplBadDiscUnionStruct::my_union()
{
    return m_my_union;
}


size_t SimplBadDiscUnionStruct::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SimplBadDiscUnionStruct_max_key_cdr_typesize;
}

bool SimplBadDiscUnionStruct::isKeyDefined()
{
    return false;
}

void SimplBadDiscUnionStruct::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}
