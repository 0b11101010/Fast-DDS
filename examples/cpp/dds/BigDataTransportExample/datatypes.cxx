// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file datatypes.cpp
 * This source file contains the implementation of the described types in the IDL file.
 *
 * This file was generated by the tool fastddsgen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "datatypes.h"
#include <fastcdr/Cdr.h>


#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>


Int32::Int32()
{

}

Int32::~Int32()
{
}

Int32::Int32(
        const Int32& x)
{
    m_data = x.m_data;
}

Int32::Int32(
        Int32&& x) noexcept
{
    m_data = x.m_data;
}

Int32& Int32::operator =(
        const Int32& x)
{

    m_data = x.m_data;
    return *this;
}

Int32& Int32::operator =(
        Int32&& x) noexcept
{

    m_data = x.m_data;
    return *this;
}

bool Int32::operator ==(
        const Int32& x) const
{
    return (m_data == x.m_data);
}

bool Int32::operator !=(
        const Int32& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member data
 * @param _data New value for member data
 */
void Int32::data(
        int32_t _data)
{
    m_data = _data;
}

/*!
 * @brief This function returns the value of member data
 * @return Value of member data
 */
int32_t Int32::data() const
{
    return m_data;
}

/*!
 * @brief This function returns a reference to member data
 * @return Reference to member data
 */
int32_t& Int32::data()
{
    return m_data;
}


Int64::Int64()
{

}

Int64::~Int64()
{
}

Int64::Int64(
        const Int64& x)
{
    m_data = x.m_data;
}

Int64::Int64(
        Int64&& x) noexcept
{
    m_data = x.m_data;
}

Int64& Int64::operator =(
        const Int64& x)
{

    m_data = x.m_data;
    return *this;
}

Int64& Int64::operator =(
        Int64&& x) noexcept
{

    m_data = x.m_data;
    return *this;
}

bool Int64::operator ==(
        const Int64& x) const
{
    return (m_data == x.m_data);
}

bool Int64::operator !=(
        const Int64& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member data
 * @param _data New value for member data
 */
void Int64::data(
        int64_t _data)
{
    m_data = _data;
}

/*!
 * @brief This function returns the value of member data
 * @return Value of member data
 */
int64_t Int64::data() const
{
    return m_data;
}

/*!
 * @brief This function returns a reference to member data
 * @return Reference to member data
 */
int64_t& Int64::data()
{
    return m_data;
}


Float32::Float32()
{

}

Float32::~Float32()
{
}

Float32::Float32(
        const Float32& x)
{
    m_data = x.m_data;
}

Float32::Float32(
        Float32&& x) noexcept
{
    m_data = x.m_data;
}

Float32& Float32::operator =(
        const Float32& x)
{

    m_data = x.m_data;
    return *this;
}

Float32& Float32::operator =(
        Float32&& x) noexcept
{

    m_data = x.m_data;
    return *this;
}

bool Float32::operator ==(
        const Float32& x) const
{
    return (m_data == x.m_data);
}

bool Float32::operator !=(
        const Float32& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member data
 * @param _data New value for member data
 */
void Float32::data(
        float _data)
{
    m_data = _data;
}

/*!
 * @brief This function returns the value of member data
 * @return Value of member data
 */
float Float32::data() const
{
    return m_data;
}

/*!
 * @brief This function returns a reference to member data
 * @return Reference to member data
 */
float& Float32::data()
{
    return m_data;
}


Float64::Float64()
{

}

Float64::~Float64()
{
}

Float64::Float64(
        const Float64& x)
{
    m_data = x.m_data;
}

Float64::Float64(
        Float64&& x) noexcept
{
    m_data = x.m_data;
}

Float64& Float64::operator =(
        const Float64& x)
{

    m_data = x.m_data;
    return *this;
}

Float64& Float64::operator =(
        Float64&& x) noexcept
{

    m_data = x.m_data;
    return *this;
}

bool Float64::operator ==(
        const Float64& x) const
{
    return (m_data == x.m_data);
}

bool Float64::operator !=(
        const Float64& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member data
 * @param _data New value for member data
 */
void Float64::data(
        double _data)
{
    m_data = _data;
}

/*!
 * @brief This function returns the value of member data
 * @return Value of member data
 */
double Float64::data() const
{
    return m_data;
}

/*!
 * @brief This function returns a reference to member data
 * @return Reference to member data
 */
double& Float64::data()
{
    return m_data;
}


Timestamp::Timestamp()
{

}

Timestamp::~Timestamp()
{
}

Timestamp::Timestamp(
        const Timestamp& x)
{
    m_sec = x.m_sec;
    m_nanosec = x.m_nanosec;
}

Timestamp::Timestamp(
        Timestamp&& x) noexcept
{
    m_sec = x.m_sec;
    m_nanosec = x.m_nanosec;
}

Timestamp& Timestamp::operator =(
        const Timestamp& x)
{

    m_sec = x.m_sec;
    m_nanosec = x.m_nanosec;
    return *this;
}

Timestamp& Timestamp::operator =(
        Timestamp&& x) noexcept
{

    m_sec = x.m_sec;
    m_nanosec = x.m_nanosec;
    return *this;
}

bool Timestamp::operator ==(
        const Timestamp& x) const
{
    return (m_sec == x.m_sec &&
           m_nanosec == x.m_nanosec);
}

bool Timestamp::operator !=(
        const Timestamp& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member sec
 * @param _sec New value for member sec
 */
void Timestamp::sec(
        uint64_t _sec)
{
    m_sec = _sec;
}

/*!
 * @brief This function returns the value of member sec
 * @return Value of member sec
 */
uint64_t Timestamp::sec() const
{
    return m_sec;
}

/*!
 * @brief This function returns a reference to member sec
 * @return Reference to member sec
 */
uint64_t& Timestamp::sec()
{
    return m_sec;
}


/*!
 * @brief This function sets a value in member nanosec
 * @param _nanosec New value for member nanosec
 */
void Timestamp::nanosec(
        uint32_t _nanosec)
{
    m_nanosec = _nanosec;
}

/*!
 * @brief This function returns the value of member nanosec
 * @return Value of member nanosec
 */
uint32_t Timestamp::nanosec() const
{
    return m_nanosec;
}

/*!
 * @brief This function returns a reference to member nanosec
 * @return Reference to member nanosec
 */
uint32_t& Timestamp::nanosec()
{
    return m_nanosec;
}


Header::Header()
{

}

Header::~Header()
{
}

Header::Header(
        const Header& x)
{
    m_sec = x.m_sec;
    m_nanosec = x.m_nanosec;
    m_frame_id = x.m_frame_id;
}

Header::Header(
        Header&& x) noexcept
{
    m_sec = x.m_sec;
    m_nanosec = x.m_nanosec;
    m_frame_id = std::move(x.m_frame_id);
}

Header& Header::operator =(
        const Header& x)
{

    m_sec = x.m_sec;
    m_nanosec = x.m_nanosec;
    m_frame_id = x.m_frame_id;
    return *this;
}

Header& Header::operator =(
        Header&& x) noexcept
{

    m_sec = x.m_sec;
    m_nanosec = x.m_nanosec;
    m_frame_id = std::move(x.m_frame_id);
    return *this;
}

bool Header::operator ==(
        const Header& x) const
{
    return (m_sec == x.m_sec &&
           m_nanosec == x.m_nanosec &&
           m_frame_id == x.m_frame_id);
}

bool Header::operator !=(
        const Header& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member sec
 * @param _sec New value for member sec
 */
void Header::sec(
        int32_t _sec)
{
    m_sec = _sec;
}

/*!
 * @brief This function returns the value of member sec
 * @return Value of member sec
 */
int32_t Header::sec() const
{
    return m_sec;
}

/*!
 * @brief This function returns a reference to member sec
 * @return Reference to member sec
 */
int32_t& Header::sec()
{
    return m_sec;
}


/*!
 * @brief This function sets a value in member nanosec
 * @param _nanosec New value for member nanosec
 */
void Header::nanosec(
        uint32_t _nanosec)
{
    m_nanosec = _nanosec;
}

/*!
 * @brief This function returns the value of member nanosec
 * @return Value of member nanosec
 */
uint32_t Header::nanosec() const
{
    return m_nanosec;
}

/*!
 * @brief This function returns a reference to member nanosec
 * @return Reference to member nanosec
 */
uint32_t& Header::nanosec()
{
    return m_nanosec;
}


/*!
 * @brief This function copies the value in member frame_id
 * @param _frame_id New value to be copied in member frame_id
 */
void Header::frame_id(
        const eprosima::fastcdr::fixed_string<256>& _frame_id)
{
    m_frame_id = _frame_id;
}

/*!
 * @brief This function moves the value in member frame_id
 * @param _frame_id New value to be moved in member frame_id
 */
void Header::frame_id(
        eprosima::fastcdr::fixed_string<256>&& _frame_id)
{
    m_frame_id = std::move(_frame_id);
}

/*!
 * @brief This function returns a constant reference to member frame_id
 * @return Constant reference to member frame_id
 */
const eprosima::fastcdr::fixed_string<256>& Header::frame_id() const
{
    return m_frame_id;
}

/*!
 * @brief This function returns a reference to member frame_id
 * @return Reference to member frame_id
 */
eprosima::fastcdr::fixed_string<256>& Header::frame_id()
{
    return m_frame_id;
}


Point::Point()
{

}

Point::~Point()
{
}

Point::Point(
        const Point& x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
}

Point::Point(
        Point&& x) noexcept
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
}

Point& Point::operator =(
        const Point& x)
{

    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
    return *this;
}

Point& Point::operator =(
        Point&& x) noexcept
{

    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
    return *this;
}

bool Point::operator ==(
        const Point& x) const
{
    return (m_x == x.m_x &&
           m_y == x.m_y &&
           m_z == x.m_z);
}

bool Point::operator !=(
        const Point& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member x
 * @param _x New value for member x
 */
void Point::x(
        double _x)
{
    m_x = _x;
}

/*!
 * @brief This function returns the value of member x
 * @return Value of member x
 */
double Point::x() const
{
    return m_x;
}

/*!
 * @brief This function returns a reference to member x
 * @return Reference to member x
 */
double& Point::x()
{
    return m_x;
}


/*!
 * @brief This function sets a value in member y
 * @param _y New value for member y
 */
void Point::y(
        double _y)
{
    m_y = _y;
}

/*!
 * @brief This function returns the value of member y
 * @return Value of member y
 */
double Point::y() const
{
    return m_y;
}

/*!
 * @brief This function returns a reference to member y
 * @return Reference to member y
 */
double& Point::y()
{
    return m_y;
}


/*!
 * @brief This function sets a value in member z
 * @param _z New value for member z
 */
void Point::z(
        double _z)
{
    m_z = _z;
}

/*!
 * @brief This function returns the value of member z
 * @return Value of member z
 */
double Point::z() const
{
    return m_z;
}

/*!
 * @brief This function returns a reference to member z
 * @return Reference to member z
 */
double& Point::z()
{
    return m_z;
}


Quaternion::Quaternion()
{

}

Quaternion::~Quaternion()
{
}

Quaternion::Quaternion(
        const Quaternion& x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
    m_w = x.m_w;
}

Quaternion::Quaternion(
        Quaternion&& x) noexcept
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
    m_w = x.m_w;
}

Quaternion& Quaternion::operator =(
        const Quaternion& x)
{

    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
    m_w = x.m_w;
    return *this;
}

Quaternion& Quaternion::operator =(
        Quaternion&& x) noexcept
{

    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
    m_w = x.m_w;
    return *this;
}

bool Quaternion::operator ==(
        const Quaternion& x) const
{
    return (m_x == x.m_x &&
           m_y == x.m_y &&
           m_z == x.m_z &&
           m_w == x.m_w);
}

bool Quaternion::operator !=(
        const Quaternion& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member x
 * @param _x New value for member x
 */
void Quaternion::x(
        double _x)
{
    m_x = _x;
}

/*!
 * @brief This function returns the value of member x
 * @return Value of member x
 */
double Quaternion::x() const
{
    return m_x;
}

/*!
 * @brief This function returns a reference to member x
 * @return Reference to member x
 */
double& Quaternion::x()
{
    return m_x;
}


/*!
 * @brief This function sets a value in member y
 * @param _y New value for member y
 */
void Quaternion::y(
        double _y)
{
    m_y = _y;
}

/*!
 * @brief This function returns the value of member y
 * @return Value of member y
 */
double Quaternion::y() const
{
    return m_y;
}

/*!
 * @brief This function returns a reference to member y
 * @return Reference to member y
 */
double& Quaternion::y()
{
    return m_y;
}


/*!
 * @brief This function sets a value in member z
 * @param _z New value for member z
 */
void Quaternion::z(
        double _z)
{
    m_z = _z;
}

/*!
 * @brief This function returns the value of member z
 * @return Value of member z
 */
double Quaternion::z() const
{
    return m_z;
}

/*!
 * @brief This function returns a reference to member z
 * @return Reference to member z
 */
double& Quaternion::z()
{
    return m_z;
}


/*!
 * @brief This function sets a value in member w
 * @param _w New value for member w
 */
void Quaternion::w(
        double _w)
{
    m_w = _w;
}

/*!
 * @brief This function returns the value of member w
 * @return Value of member w
 */
double Quaternion::w() const
{
    return m_w;
}

/*!
 * @brief This function returns a reference to member w
 * @return Reference to member w
 */
double& Quaternion::w()
{
    return m_w;
}


Vector3::Vector3()
{

}

Vector3::~Vector3()
{
}

Vector3::Vector3(
        const Vector3& x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
}

Vector3::Vector3(
        Vector3&& x) noexcept
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
}

Vector3& Vector3::operator =(
        const Vector3& x)
{

    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
    return *this;
}

Vector3& Vector3::operator =(
        Vector3&& x) noexcept
{

    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
    return *this;
}

bool Vector3::operator ==(
        const Vector3& x) const
{
    return (m_x == x.m_x &&
           m_y == x.m_y &&
           m_z == x.m_z);
}

bool Vector3::operator !=(
        const Vector3& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member x
 * @param _x New value for member x
 */
void Vector3::x(
        double _x)
{
    m_x = _x;
}

/*!
 * @brief This function returns the value of member x
 * @return Value of member x
 */
double Vector3::x() const
{
    return m_x;
}

/*!
 * @brief This function returns a reference to member x
 * @return Reference to member x
 */
double& Vector3::x()
{
    return m_x;
}


/*!
 * @brief This function sets a value in member y
 * @param _y New value for member y
 */
void Vector3::y(
        double _y)
{
    m_y = _y;
}

/*!
 * @brief This function returns the value of member y
 * @return Value of member y
 */
double Vector3::y() const
{
    return m_y;
}

/*!
 * @brief This function returns a reference to member y
 * @return Reference to member y
 */
double& Vector3::y()
{
    return m_y;
}


/*!
 * @brief This function sets a value in member z
 * @param _z New value for member z
 */
void Vector3::z(
        double _z)
{
    m_z = _z;
}

/*!
 * @brief This function returns the value of member z
 * @return Value of member z
 */
double Vector3::z() const
{
    return m_z;
}

/*!
 * @brief This function returns a reference to member z
 * @return Reference to member z
 */
double& Vector3::z()
{
    return m_z;
}


Vector3Stamped::Vector3Stamped()
{

}

Vector3Stamped::~Vector3Stamped()
{
}

Vector3Stamped::Vector3Stamped(
        const Vector3Stamped& x)
{
    m_header_value = x.m_header_value;
    m_vector = x.m_vector;
}

Vector3Stamped::Vector3Stamped(
        Vector3Stamped&& x) noexcept
{
    m_header_value = std::move(x.m_header_value);
    m_vector = std::move(x.m_vector);
}

Vector3Stamped& Vector3Stamped::operator =(
        const Vector3Stamped& x)
{

    m_header_value = x.m_header_value;
    m_vector = x.m_vector;
    return *this;
}

Vector3Stamped& Vector3Stamped::operator =(
        Vector3Stamped&& x) noexcept
{

    m_header_value = std::move(x.m_header_value);
    m_vector = std::move(x.m_vector);
    return *this;
}

bool Vector3Stamped::operator ==(
        const Vector3Stamped& x) const
{
    return (m_header_value == x.m_header_value &&
           m_vector == x.m_vector);
}

bool Vector3Stamped::operator !=(
        const Vector3Stamped& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member header_value
 * @param _header_value New value to be copied in member header_value
 */
void Vector3Stamped::header_value(
        const Header& _header_value)
{
    m_header_value = _header_value;
}

/*!
 * @brief This function moves the value in member header_value
 * @param _header_value New value to be moved in member header_value
 */
void Vector3Stamped::header_value(
        Header&& _header_value)
{
    m_header_value = std::move(_header_value);
}

/*!
 * @brief This function returns a constant reference to member header_value
 * @return Constant reference to member header_value
 */
const Header& Vector3Stamped::header_value() const
{
    return m_header_value;
}

/*!
 * @brief This function returns a reference to member header_value
 * @return Reference to member header_value
 */
Header& Vector3Stamped::header_value()
{
    return m_header_value;
}


/*!
 * @brief This function copies the value in member vector
 * @param _vector New value to be copied in member vector
 */
void Vector3Stamped::vector(
        const Vector3& _vector)
{
    m_vector = _vector;
}

/*!
 * @brief This function moves the value in member vector
 * @param _vector New value to be moved in member vector
 */
void Vector3Stamped::vector(
        Vector3&& _vector)
{
    m_vector = std::move(_vector);
}

/*!
 * @brief This function returns a constant reference to member vector
 * @return Constant reference to member vector
 */
const Vector3& Vector3Stamped::vector() const
{
    return m_vector;
}

/*!
 * @brief This function returns a reference to member vector
 * @return Reference to member vector
 */
Vector3& Vector3Stamped::vector()
{
    return m_vector;
}


Pose::Pose()
{

}

Pose::~Pose()
{
}

Pose::Pose(
        const Pose& x)
{
    m_position = x.m_position;
    m_orientation = x.m_orientation;
}

Pose::Pose(
        Pose&& x) noexcept
{
    m_position = std::move(x.m_position);
    m_orientation = std::move(x.m_orientation);
}

Pose& Pose::operator =(
        const Pose& x)
{

    m_position = x.m_position;
    m_orientation = x.m_orientation;
    return *this;
}

Pose& Pose::operator =(
        Pose&& x) noexcept
{

    m_position = std::move(x.m_position);
    m_orientation = std::move(x.m_orientation);
    return *this;
}

bool Pose::operator ==(
        const Pose& x) const
{
    return (m_position == x.m_position &&
           m_orientation == x.m_orientation);
}

bool Pose::operator !=(
        const Pose& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member position
 * @param _position New value to be copied in member position
 */
void Pose::position(
        const Point& _position)
{
    m_position = _position;
}

/*!
 * @brief This function moves the value in member position
 * @param _position New value to be moved in member position
 */
void Pose::position(
        Point&& _position)
{
    m_position = std::move(_position);
}

/*!
 * @brief This function returns a constant reference to member position
 * @return Constant reference to member position
 */
const Point& Pose::position() const
{
    return m_position;
}

/*!
 * @brief This function returns a reference to member position
 * @return Reference to member position
 */
Point& Pose::position()
{
    return m_position;
}


/*!
 * @brief This function copies the value in member orientation
 * @param _orientation New value to be copied in member orientation
 */
void Pose::orientation(
        const Quaternion& _orientation)
{
    m_orientation = _orientation;
}

/*!
 * @brief This function moves the value in member orientation
 * @param _orientation New value to be moved in member orientation
 */
void Pose::orientation(
        Quaternion&& _orientation)
{
    m_orientation = std::move(_orientation);
}

/*!
 * @brief This function returns a constant reference to member orientation
 * @return Constant reference to member orientation
 */
const Quaternion& Pose::orientation() const
{
    return m_orientation;
}

/*!
 * @brief This function returns a reference to member orientation
 * @return Reference to member orientation
 */
Quaternion& Pose::orientation()
{
    return m_orientation;
}


Twist::Twist()
{

}

Twist::~Twist()
{
}

Twist::Twist(
        const Twist& x)
{
    m_linear = x.m_linear;
    m_angular = x.m_angular;
}

Twist::Twist(
        Twist&& x) noexcept
{
    m_linear = std::move(x.m_linear);
    m_angular = std::move(x.m_angular);
}

Twist& Twist::operator =(
        const Twist& x)
{

    m_linear = x.m_linear;
    m_angular = x.m_angular;
    return *this;
}

Twist& Twist::operator =(
        Twist&& x) noexcept
{

    m_linear = std::move(x.m_linear);
    m_angular = std::move(x.m_angular);
    return *this;
}

bool Twist::operator ==(
        const Twist& x) const
{
    return (m_linear == x.m_linear &&
           m_angular == x.m_angular);
}

bool Twist::operator !=(
        const Twist& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member linear
 * @param _linear New value to be copied in member linear
 */
void Twist::linear(
        const Vector3& _linear)
{
    m_linear = _linear;
}

/*!
 * @brief This function moves the value in member linear
 * @param _linear New value to be moved in member linear
 */
void Twist::linear(
        Vector3&& _linear)
{
    m_linear = std::move(_linear);
}

/*!
 * @brief This function returns a constant reference to member linear
 * @return Constant reference to member linear
 */
const Vector3& Twist::linear() const
{
    return m_linear;
}

/*!
 * @brief This function returns a reference to member linear
 * @return Reference to member linear
 */
Vector3& Twist::linear()
{
    return m_linear;
}


/*!
 * @brief This function copies the value in member angular
 * @param _angular New value to be copied in member angular
 */
void Twist::angular(
        const Vector3& _angular)
{
    m_angular = _angular;
}

/*!
 * @brief This function moves the value in member angular
 * @param _angular New value to be moved in member angular
 */
void Twist::angular(
        Vector3&& _angular)
{
    m_angular = std::move(_angular);
}

/*!
 * @brief This function returns a constant reference to member angular
 * @return Constant reference to member angular
 */
const Vector3& Twist::angular() const
{
    return m_angular;
}

/*!
 * @brief This function returns a reference to member angular
 * @return Reference to member angular
 */
Vector3& Twist::angular()
{
    return m_angular;
}


TwistWithCovariance::TwistWithCovariance()
{

}

TwistWithCovariance::~TwistWithCovariance()
{
}

TwistWithCovariance::TwistWithCovariance(
        const TwistWithCovariance& x)
{
    m_twist_value = x.m_twist_value;
    m_covariance = x.m_covariance;
}

TwistWithCovariance::TwistWithCovariance(
        TwistWithCovariance&& x) noexcept
{
    m_twist_value = std::move(x.m_twist_value);
    m_covariance = std::move(x.m_covariance);
}

TwistWithCovariance& TwistWithCovariance::operator =(
        const TwistWithCovariance& x)
{

    m_twist_value = x.m_twist_value;
    m_covariance = x.m_covariance;
    return *this;
}

TwistWithCovariance& TwistWithCovariance::operator =(
        TwistWithCovariance&& x) noexcept
{

    m_twist_value = std::move(x.m_twist_value);
    m_covariance = std::move(x.m_covariance);
    return *this;
}

bool TwistWithCovariance::operator ==(
        const TwistWithCovariance& x) const
{
    return (m_twist_value == x.m_twist_value &&
           m_covariance == x.m_covariance);
}

bool TwistWithCovariance::operator !=(
        const TwistWithCovariance& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member twist_value
 * @param _twist_value New value to be copied in member twist_value
 */
void TwistWithCovariance::twist_value(
        const Twist& _twist_value)
{
    m_twist_value = _twist_value;
}

/*!
 * @brief This function moves the value in member twist_value
 * @param _twist_value New value to be moved in member twist_value
 */
void TwistWithCovariance::twist_value(
        Twist&& _twist_value)
{
    m_twist_value = std::move(_twist_value);
}

/*!
 * @brief This function returns a constant reference to member twist_value
 * @return Constant reference to member twist_value
 */
const Twist& TwistWithCovariance::twist_value() const
{
    return m_twist_value;
}

/*!
 * @brief This function returns a reference to member twist_value
 * @return Reference to member twist_value
 */
Twist& TwistWithCovariance::twist_value()
{
    return m_twist_value;
}


/*!
 * @brief This function copies the value in member covariance
 * @param _covariance New value to be copied in member covariance
 */
void TwistWithCovariance::covariance(
        const std::vector<double>& _covariance)
{
    m_covariance = _covariance;
}

/*!
 * @brief This function moves the value in member covariance
 * @param _covariance New value to be moved in member covariance
 */
void TwistWithCovariance::covariance(
        std::vector<double>&& _covariance)
{
    m_covariance = std::move(_covariance);
}

/*!
 * @brief This function returns a constant reference to member covariance
 * @return Constant reference to member covariance
 */
const std::vector<double>& TwistWithCovariance::covariance() const
{
    return m_covariance;
}

/*!
 * @brief This function returns a reference to member covariance
 * @return Reference to member covariance
 */
std::vector<double>& TwistWithCovariance::covariance()
{
    return m_covariance;
}


TwistWithCovarianceStamped::TwistWithCovarianceStamped()
{

}

TwistWithCovarianceStamped::~TwistWithCovarianceStamped()
{
}

TwistWithCovarianceStamped::TwistWithCovarianceStamped(
        const TwistWithCovarianceStamped& x)
{
    m_header_value = x.m_header_value;
    m_twist_tc = x.m_twist_tc;
}

TwistWithCovarianceStamped::TwistWithCovarianceStamped(
        TwistWithCovarianceStamped&& x) noexcept
{
    m_header_value = std::move(x.m_header_value);
    m_twist_tc = std::move(x.m_twist_tc);
}

TwistWithCovarianceStamped& TwistWithCovarianceStamped::operator =(
        const TwistWithCovarianceStamped& x)
{

    m_header_value = x.m_header_value;
    m_twist_tc = x.m_twist_tc;
    return *this;
}

TwistWithCovarianceStamped& TwistWithCovarianceStamped::operator =(
        TwistWithCovarianceStamped&& x) noexcept
{

    m_header_value = std::move(x.m_header_value);
    m_twist_tc = std::move(x.m_twist_tc);
    return *this;
}

bool TwistWithCovarianceStamped::operator ==(
        const TwistWithCovarianceStamped& x) const
{
    return (m_header_value == x.m_header_value &&
           m_twist_tc == x.m_twist_tc);
}

bool TwistWithCovarianceStamped::operator !=(
        const TwistWithCovarianceStamped& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member header_value
 * @param _header_value New value to be copied in member header_value
 */
void TwistWithCovarianceStamped::header_value(
        const Header& _header_value)
{
    m_header_value = _header_value;
}

/*!
 * @brief This function moves the value in member header_value
 * @param _header_value New value to be moved in member header_value
 */
void TwistWithCovarianceStamped::header_value(
        Header&& _header_value)
{
    m_header_value = std::move(_header_value);
}

/*!
 * @brief This function returns a constant reference to member header_value
 * @return Constant reference to member header_value
 */
const Header& TwistWithCovarianceStamped::header_value() const
{
    return m_header_value;
}

/*!
 * @brief This function returns a reference to member header_value
 * @return Reference to member header_value
 */
Header& TwistWithCovarianceStamped::header_value()
{
    return m_header_value;
}


/*!
 * @brief This function copies the value in member twist_tc
 * @param _twist_tc New value to be copied in member twist_tc
 */
void TwistWithCovarianceStamped::twist_tc(
        const TwistWithCovariance& _twist_tc)
{
    m_twist_tc = _twist_tc;
}

/*!
 * @brief This function moves the value in member twist_tc
 * @param _twist_tc New value to be moved in member twist_tc
 */
void TwistWithCovarianceStamped::twist_tc(
        TwistWithCovariance&& _twist_tc)
{
    m_twist_tc = std::move(_twist_tc);
}

/*!
 * @brief This function returns a constant reference to member twist_tc
 * @return Constant reference to member twist_tc
 */
const TwistWithCovariance& TwistWithCovarianceStamped::twist_tc() const
{
    return m_twist_tc;
}

/*!
 * @brief This function returns a reference to member twist_tc
 * @return Reference to member twist_tc
 */
TwistWithCovariance& TwistWithCovarianceStamped::twist_tc()
{
    return m_twist_tc;
}


Wrench::Wrench()
{

}

Wrench::~Wrench()
{
}

Wrench::Wrench(
        const Wrench& x)
{
    m_force = x.m_force;
    m_torque = x.m_torque;
}

Wrench::Wrench(
        Wrench&& x) noexcept
{
    m_force = std::move(x.m_force);
    m_torque = std::move(x.m_torque);
}

Wrench& Wrench::operator =(
        const Wrench& x)
{

    m_force = x.m_force;
    m_torque = x.m_torque;
    return *this;
}

Wrench& Wrench::operator =(
        Wrench&& x) noexcept
{

    m_force = std::move(x.m_force);
    m_torque = std::move(x.m_torque);
    return *this;
}

bool Wrench::operator ==(
        const Wrench& x) const
{
    return (m_force == x.m_force &&
           m_torque == x.m_torque);
}

bool Wrench::operator !=(
        const Wrench& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member force
 * @param _force New value to be copied in member force
 */
void Wrench::force(
        const Vector3& _force)
{
    m_force = _force;
}

/*!
 * @brief This function moves the value in member force
 * @param _force New value to be moved in member force
 */
void Wrench::force(
        Vector3&& _force)
{
    m_force = std::move(_force);
}

/*!
 * @brief This function returns a constant reference to member force
 * @return Constant reference to member force
 */
const Vector3& Wrench::force() const
{
    return m_force;
}

/*!
 * @brief This function returns a reference to member force
 * @return Reference to member force
 */
Vector3& Wrench::force()
{
    return m_force;
}


/*!
 * @brief This function copies the value in member torque
 * @param _torque New value to be copied in member torque
 */
void Wrench::torque(
        const Vector3& _torque)
{
    m_torque = _torque;
}

/*!
 * @brief This function moves the value in member torque
 * @param _torque New value to be moved in member torque
 */
void Wrench::torque(
        Vector3&& _torque)
{
    m_torque = std::move(_torque);
}

/*!
 * @brief This function returns a constant reference to member torque
 * @return Constant reference to member torque
 */
const Vector3& Wrench::torque() const
{
    return m_torque;
}

/*!
 * @brief This function returns a reference to member torque
 * @return Reference to member torque
 */
Vector3& Wrench::torque()
{
    return m_torque;
}


WrenchStamped::WrenchStamped()
{

}

WrenchStamped::~WrenchStamped()
{
}

WrenchStamped::WrenchStamped(
        const WrenchStamped& x)
{
    m_header_value = x.m_header_value;
    m_wrench_value = x.m_wrench_value;
}

WrenchStamped::WrenchStamped(
        WrenchStamped&& x) noexcept
{
    m_header_value = std::move(x.m_header_value);
    m_wrench_value = std::move(x.m_wrench_value);
}

WrenchStamped& WrenchStamped::operator =(
        const WrenchStamped& x)
{

    m_header_value = x.m_header_value;
    m_wrench_value = x.m_wrench_value;
    return *this;
}

WrenchStamped& WrenchStamped::operator =(
        WrenchStamped&& x) noexcept
{

    m_header_value = std::move(x.m_header_value);
    m_wrench_value = std::move(x.m_wrench_value);
    return *this;
}

bool WrenchStamped::operator ==(
        const WrenchStamped& x) const
{
    return (m_header_value == x.m_header_value &&
           m_wrench_value == x.m_wrench_value);
}

bool WrenchStamped::operator !=(
        const WrenchStamped& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member header_value
 * @param _header_value New value to be copied in member header_value
 */
void WrenchStamped::header_value(
        const Header& _header_value)
{
    m_header_value = _header_value;
}

/*!
 * @brief This function moves the value in member header_value
 * @param _header_value New value to be moved in member header_value
 */
void WrenchStamped::header_value(
        Header&& _header_value)
{
    m_header_value = std::move(_header_value);
}

/*!
 * @brief This function returns a constant reference to member header_value
 * @return Constant reference to member header_value
 */
const Header& WrenchStamped::header_value() const
{
    return m_header_value;
}

/*!
 * @brief This function returns a reference to member header_value
 * @return Reference to member header_value
 */
Header& WrenchStamped::header_value()
{
    return m_header_value;
}


/*!
 * @brief This function copies the value in member wrench_value
 * @param _wrench_value New value to be copied in member wrench_value
 */
void WrenchStamped::wrench_value(
        const Wrench& _wrench_value)
{
    m_wrench_value = _wrench_value;
}

/*!
 * @brief This function moves the value in member wrench_value
 * @param _wrench_value New value to be moved in member wrench_value
 */
void WrenchStamped::wrench_value(
        Wrench&& _wrench_value)
{
    m_wrench_value = std::move(_wrench_value);
}

/*!
 * @brief This function returns a constant reference to member wrench_value
 * @return Constant reference to member wrench_value
 */
const Wrench& WrenchStamped::wrench_value() const
{
    return m_wrench_value;
}

/*!
 * @brief This function returns a reference to member wrench_value
 * @return Reference to member wrench_value
 */
Wrench& WrenchStamped::wrench_value()
{
    return m_wrench_value;
}


Image::Image()
{

}

Image::~Image()
{
}

Image::Image(
        const Image& x)
{
    m_header_value = x.m_header_value;
    m_height = x.m_height;
    m_width = x.m_width;
    m_encoding = x.m_encoding;
    m_is_bigendian = x.m_is_bigendian;
    m_step = x.m_step;
    m_data = x.m_data;
}

Image::Image(
        Image&& x) noexcept
{
    m_header_value = std::move(x.m_header_value);
    m_height = x.m_height;
    m_width = x.m_width;
    m_encoding = std::move(x.m_encoding);
    m_is_bigendian = x.m_is_bigendian;
    m_step = x.m_step;
    m_data = std::move(x.m_data);
}

Image& Image::operator =(
        const Image& x)
{

    m_header_value = x.m_header_value;
    m_height = x.m_height;
    m_width = x.m_width;
    m_encoding = x.m_encoding;
    m_is_bigendian = x.m_is_bigendian;
    m_step = x.m_step;
    m_data = x.m_data;
    return *this;
}

Image& Image::operator =(
        Image&& x) noexcept
{

    m_header_value = std::move(x.m_header_value);
    m_height = x.m_height;
    m_width = x.m_width;
    m_encoding = std::move(x.m_encoding);
    m_is_bigendian = x.m_is_bigendian;
    m_step = x.m_step;
    m_data = std::move(x.m_data);
    return *this;
}

bool Image::operator ==(
        const Image& x) const
{
    return (m_header_value == x.m_header_value &&
           m_height == x.m_height &&
           m_width == x.m_width &&
           m_encoding == x.m_encoding &&
           m_is_bigendian == x.m_is_bigendian &&
           m_step == x.m_step &&
           m_data == x.m_data);
}

bool Image::operator !=(
        const Image& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member header_value
 * @param _header_value New value to be copied in member header_value
 */
void Image::header_value(
        const Header& _header_value)
{
    m_header_value = _header_value;
}

/*!
 * @brief This function moves the value in member header_value
 * @param _header_value New value to be moved in member header_value
 */
void Image::header_value(
        Header&& _header_value)
{
    m_header_value = std::move(_header_value);
}

/*!
 * @brief This function returns a constant reference to member header_value
 * @return Constant reference to member header_value
 */
const Header& Image::header_value() const
{
    return m_header_value;
}

/*!
 * @brief This function returns a reference to member header_value
 * @return Reference to member header_value
 */
Header& Image::header_value()
{
    return m_header_value;
}


/*!
 * @brief This function sets a value in member height
 * @param _height New value for member height
 */
void Image::height(
        uint32_t _height)
{
    m_height = _height;
}

/*!
 * @brief This function returns the value of member height
 * @return Value of member height
 */
uint32_t Image::height() const
{
    return m_height;
}

/*!
 * @brief This function returns a reference to member height
 * @return Reference to member height
 */
uint32_t& Image::height()
{
    return m_height;
}


/*!
 * @brief This function sets a value in member width
 * @param _width New value for member width
 */
void Image::width(
        uint32_t _width)
{
    m_width = _width;
}

/*!
 * @brief This function returns the value of member width
 * @return Value of member width
 */
uint32_t Image::width() const
{
    return m_width;
}

/*!
 * @brief This function returns a reference to member width
 * @return Reference to member width
 */
uint32_t& Image::width()
{
    return m_width;
}


/*!
 * @brief This function copies the value in member encoding
 * @param _encoding New value to be copied in member encoding
 */
void Image::encoding(
        const eprosima::fastcdr::fixed_string<256>& _encoding)
{
    m_encoding = _encoding;
}

/*!
 * @brief This function moves the value in member encoding
 * @param _encoding New value to be moved in member encoding
 */
void Image::encoding(
        eprosima::fastcdr::fixed_string<256>&& _encoding)
{
    m_encoding = std::move(_encoding);
}

/*!
 * @brief This function returns a constant reference to member encoding
 * @return Constant reference to member encoding
 */
const eprosima::fastcdr::fixed_string<256>& Image::encoding() const
{
    return m_encoding;
}

/*!
 * @brief This function returns a reference to member encoding
 * @return Reference to member encoding
 */
eprosima::fastcdr::fixed_string<256>& Image::encoding()
{
    return m_encoding;
}


/*!
 * @brief This function sets a value in member is_bigendian
 * @param _is_bigendian New value for member is_bigendian
 */
void Image::is_bigendian(
        bool _is_bigendian)
{
    m_is_bigendian = _is_bigendian;
}

/*!
 * @brief This function returns the value of member is_bigendian
 * @return Value of member is_bigendian
 */
bool Image::is_bigendian() const
{
    return m_is_bigendian;
}

/*!
 * @brief This function returns a reference to member is_bigendian
 * @return Reference to member is_bigendian
 */
bool& Image::is_bigendian()
{
    return m_is_bigendian;
}


/*!
 * @brief This function sets a value in member step
 * @param _step New value for member step
 */
void Image::step(
        uint32_t _step)
{
    m_step = _step;
}

/*!
 * @brief This function returns the value of member step
 * @return Value of member step
 */
uint32_t Image::step() const
{
    return m_step;
}

/*!
 * @brief This function returns a reference to member step
 * @return Reference to member step
 */
uint32_t& Image::step()
{
    return m_step;
}


/*!
 * @brief This function copies the value in member data
 * @param _data New value to be copied in member data
 */
void Image::data(
        const std::vector<uint8_t>& _data)
{
    m_data = _data;
}

/*!
 * @brief This function moves the value in member data
 * @param _data New value to be moved in member data
 */
void Image::data(
        std::vector<uint8_t>&& _data)
{
    m_data = std::move(_data);
}

/*!
 * @brief This function returns a constant reference to member data
 * @return Constant reference to member data
 */
const std::vector<uint8_t>& Image::data() const
{
    return m_data;
}

/*!
 * @brief This function returns a reference to member data
 * @return Reference to member data
 */
std::vector<uint8_t>& Image::data()
{
    return m_data;
}










PointField::PointField()
{

}

PointField::~PointField()
{
}

PointField::PointField(
        const PointField& x)
{
    m_name = x.m_name;
    m_offset = x.m_offset;
    m_datatype = x.m_datatype;
    m_count = x.m_count;
}

PointField::PointField(
        PointField&& x) noexcept
{
    m_name = std::move(x.m_name);
    m_offset = x.m_offset;
    m_datatype = x.m_datatype;
    m_count = x.m_count;
}

PointField& PointField::operator =(
        const PointField& x)
{

    m_name = x.m_name;
    m_offset = x.m_offset;
    m_datatype = x.m_datatype;
    m_count = x.m_count;
    return *this;
}

PointField& PointField::operator =(
        PointField&& x) noexcept
{

    m_name = std::move(x.m_name);
    m_offset = x.m_offset;
    m_datatype = x.m_datatype;
    m_count = x.m_count;
    return *this;
}

bool PointField::operator ==(
        const PointField& x) const
{
    return (m_name == x.m_name &&
           m_offset == x.m_offset &&
           m_datatype == x.m_datatype &&
           m_count == x.m_count);
}

bool PointField::operator !=(
        const PointField& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member name
 * @param _name New value to be copied in member name
 */
void PointField::name(
        const eprosima::fastcdr::fixed_string<256>& _name)
{
    m_name = _name;
}

/*!
 * @brief This function moves the value in member name
 * @param _name New value to be moved in member name
 */
void PointField::name(
        eprosima::fastcdr::fixed_string<256>&& _name)
{
    m_name = std::move(_name);
}

/*!
 * @brief This function returns a constant reference to member name
 * @return Constant reference to member name
 */
const eprosima::fastcdr::fixed_string<256>& PointField::name() const
{
    return m_name;
}

/*!
 * @brief This function returns a reference to member name
 * @return Reference to member name
 */
eprosima::fastcdr::fixed_string<256>& PointField::name()
{
    return m_name;
}


/*!
 * @brief This function sets a value in member offset
 * @param _offset New value for member offset
 */
void PointField::offset(
        uint32_t _offset)
{
    m_offset = _offset;
}

/*!
 * @brief This function returns the value of member offset
 * @return Value of member offset
 */
uint32_t PointField::offset() const
{
    return m_offset;
}

/*!
 * @brief This function returns a reference to member offset
 * @return Reference to member offset
 */
uint32_t& PointField::offset()
{
    return m_offset;
}


/*!
 * @brief This function sets a value in member datatype
 * @param _datatype New value for member datatype
 */
void PointField::datatype(
        uint8_t _datatype)
{
    m_datatype = _datatype;
}

/*!
 * @brief This function returns the value of member datatype
 * @return Value of member datatype
 */
uint8_t PointField::datatype() const
{
    return m_datatype;
}

/*!
 * @brief This function returns a reference to member datatype
 * @return Reference to member datatype
 */
uint8_t& PointField::datatype()
{
    return m_datatype;
}


/*!
 * @brief This function sets a value in member count
 * @param _count New value for member count
 */
void PointField::count(
        uint32_t _count)
{
    m_count = _count;
}

/*!
 * @brief This function returns the value of member count
 * @return Value of member count
 */
uint32_t PointField::count() const
{
    return m_count;
}

/*!
 * @brief This function returns a reference to member count
 * @return Reference to member count
 */
uint32_t& PointField::count()
{
    return m_count;
}


PointCloud2::PointCloud2()
{

}

PointCloud2::~PointCloud2()
{
}

PointCloud2::PointCloud2(
        const PointCloud2& x)
{
    m_header_value = x.m_header_value;
    m_height = x.m_height;
    m_width = x.m_width;
    m_fields = x.m_fields;
    m_is_bigendian = x.m_is_bigendian;
    m_point_step = x.m_point_step;
    m_row_step = x.m_row_step;
    m_data = x.m_data;
    m_is_dense = x.m_is_dense;
}

PointCloud2::PointCloud2(
        PointCloud2&& x) noexcept
{
    m_header_value = std::move(x.m_header_value);
    m_height = x.m_height;
    m_width = x.m_width;
    m_fields = std::move(x.m_fields);
    m_is_bigendian = x.m_is_bigendian;
    m_point_step = x.m_point_step;
    m_row_step = x.m_row_step;
    m_data = std::move(x.m_data);
    m_is_dense = x.m_is_dense;
}

PointCloud2& PointCloud2::operator =(
        const PointCloud2& x)
{

    m_header_value = x.m_header_value;
    m_height = x.m_height;
    m_width = x.m_width;
    m_fields = x.m_fields;
    m_is_bigendian = x.m_is_bigendian;
    m_point_step = x.m_point_step;
    m_row_step = x.m_row_step;
    m_data = x.m_data;
    m_is_dense = x.m_is_dense;
    return *this;
}

PointCloud2& PointCloud2::operator =(
        PointCloud2&& x) noexcept
{

    m_header_value = std::move(x.m_header_value);
    m_height = x.m_height;
    m_width = x.m_width;
    m_fields = std::move(x.m_fields);
    m_is_bigendian = x.m_is_bigendian;
    m_point_step = x.m_point_step;
    m_row_step = x.m_row_step;
    m_data = std::move(x.m_data);
    m_is_dense = x.m_is_dense;
    return *this;
}

bool PointCloud2::operator ==(
        const PointCloud2& x) const
{
    return (m_header_value == x.m_header_value &&
           m_height == x.m_height &&
           m_width == x.m_width &&
           m_fields == x.m_fields &&
           m_is_bigendian == x.m_is_bigendian &&
           m_point_step == x.m_point_step &&
           m_row_step == x.m_row_step &&
           m_data == x.m_data &&
           m_is_dense == x.m_is_dense);
}

bool PointCloud2::operator !=(
        const PointCloud2& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member header_value
 * @param _header_value New value to be copied in member header_value
 */
void PointCloud2::header_value(
        const Header& _header_value)
{
    m_header_value = _header_value;
}

/*!
 * @brief This function moves the value in member header_value
 * @param _header_value New value to be moved in member header_value
 */
void PointCloud2::header_value(
        Header&& _header_value)
{
    m_header_value = std::move(_header_value);
}

/*!
 * @brief This function returns a constant reference to member header_value
 * @return Constant reference to member header_value
 */
const Header& PointCloud2::header_value() const
{
    return m_header_value;
}

/*!
 * @brief This function returns a reference to member header_value
 * @return Reference to member header_value
 */
Header& PointCloud2::header_value()
{
    return m_header_value;
}


/*!
 * @brief This function sets a value in member height
 * @param _height New value for member height
 */
void PointCloud2::height(
        uint32_t _height)
{
    m_height = _height;
}

/*!
 * @brief This function returns the value of member height
 * @return Value of member height
 */
uint32_t PointCloud2::height() const
{
    return m_height;
}

/*!
 * @brief This function returns a reference to member height
 * @return Reference to member height
 */
uint32_t& PointCloud2::height()
{
    return m_height;
}


/*!
 * @brief This function sets a value in member width
 * @param _width New value for member width
 */
void PointCloud2::width(
        uint32_t _width)
{
    m_width = _width;
}

/*!
 * @brief This function returns the value of member width
 * @return Value of member width
 */
uint32_t PointCloud2::width() const
{
    return m_width;
}

/*!
 * @brief This function returns a reference to member width
 * @return Reference to member width
 */
uint32_t& PointCloud2::width()
{
    return m_width;
}


/*!
 * @brief This function copies the value in member fields
 * @param _fields New value to be copied in member fields
 */
void PointCloud2::fields(
        const std::vector<PointField>& _fields)
{
    m_fields = _fields;
}

/*!
 * @brief This function moves the value in member fields
 * @param _fields New value to be moved in member fields
 */
void PointCloud2::fields(
        std::vector<PointField>&& _fields)
{
    m_fields = std::move(_fields);
}

/*!
 * @brief This function returns a constant reference to member fields
 * @return Constant reference to member fields
 */
const std::vector<PointField>& PointCloud2::fields() const
{
    return m_fields;
}

/*!
 * @brief This function returns a reference to member fields
 * @return Reference to member fields
 */
std::vector<PointField>& PointCloud2::fields()
{
    return m_fields;
}


/*!
 * @brief This function sets a value in member is_bigendian
 * @param _is_bigendian New value for member is_bigendian
 */
void PointCloud2::is_bigendian(
        bool _is_bigendian)
{
    m_is_bigendian = _is_bigendian;
}

/*!
 * @brief This function returns the value of member is_bigendian
 * @return Value of member is_bigendian
 */
bool PointCloud2::is_bigendian() const
{
    return m_is_bigendian;
}

/*!
 * @brief This function returns a reference to member is_bigendian
 * @return Reference to member is_bigendian
 */
bool& PointCloud2::is_bigendian()
{
    return m_is_bigendian;
}


/*!
 * @brief This function sets a value in member point_step
 * @param _point_step New value for member point_step
 */
void PointCloud2::point_step(
        uint32_t _point_step)
{
    m_point_step = _point_step;
}

/*!
 * @brief This function returns the value of member point_step
 * @return Value of member point_step
 */
uint32_t PointCloud2::point_step() const
{
    return m_point_step;
}

/*!
 * @brief This function returns a reference to member point_step
 * @return Reference to member point_step
 */
uint32_t& PointCloud2::point_step()
{
    return m_point_step;
}


/*!
 * @brief This function sets a value in member row_step
 * @param _row_step New value for member row_step
 */
void PointCloud2::row_step(
        uint32_t _row_step)
{
    m_row_step = _row_step;
}

/*!
 * @brief This function returns the value of member row_step
 * @return Value of member row_step
 */
uint32_t PointCloud2::row_step() const
{
    return m_row_step;
}

/*!
 * @brief This function returns a reference to member row_step
 * @return Reference to member row_step
 */
uint32_t& PointCloud2::row_step()
{
    return m_row_step;
}


/*!
 * @brief This function copies the value in member data
 * @param _data New value to be copied in member data
 */
void PointCloud2::data(
        const std::vector<uint8_t>& _data)
{
    m_data = _data;
}

/*!
 * @brief This function moves the value in member data
 * @param _data New value to be moved in member data
 */
void PointCloud2::data(
        std::vector<uint8_t>&& _data)
{
    m_data = std::move(_data);
}

/*!
 * @brief This function returns a constant reference to member data
 * @return Constant reference to member data
 */
const std::vector<uint8_t>& PointCloud2::data() const
{
    return m_data;
}

/*!
 * @brief This function returns a reference to member data
 * @return Reference to member data
 */
std::vector<uint8_t>& PointCloud2::data()
{
    return m_data;
}


/*!
 * @brief This function sets a value in member is_dense
 * @param _is_dense New value for member is_dense
 */
void PointCloud2::is_dense(
        bool _is_dense)
{
    m_is_dense = _is_dense;
}

/*!
 * @brief This function returns the value of member is_dense
 * @return Value of member is_dense
 */
bool PointCloud2::is_dense() const
{
    return m_is_dense;
}

/*!
 * @brief This function returns a reference to member is_dense
 * @return Reference to member is_dense
 */
bool& PointCloud2::is_dense()
{
    return m_is_dense;
}


LaserScan::LaserScan()
{

}

LaserScan::~LaserScan()
{
}

LaserScan::LaserScan(
        const LaserScan& x)
{
    m_header_value = x.m_header_value;
    m_angle_min = x.m_angle_min;
    m_angle_max = x.m_angle_max;
    m_angle_increment = x.m_angle_increment;
    m_time_increment = x.m_time_increment;
    m_scan_time = x.m_scan_time;
    m_range_min = x.m_range_min;
    m_range_max = x.m_range_max;
    m_ranges = x.m_ranges;
    m_intensities = x.m_intensities;
}

LaserScan::LaserScan(
        LaserScan&& x) noexcept
{
    m_header_value = std::move(x.m_header_value);
    m_angle_min = x.m_angle_min;
    m_angle_max = x.m_angle_max;
    m_angle_increment = x.m_angle_increment;
    m_time_increment = x.m_time_increment;
    m_scan_time = x.m_scan_time;
    m_range_min = x.m_range_min;
    m_range_max = x.m_range_max;
    m_ranges = std::move(x.m_ranges);
    m_intensities = std::move(x.m_intensities);
}

LaserScan& LaserScan::operator =(
        const LaserScan& x)
{

    m_header_value = x.m_header_value;
    m_angle_min = x.m_angle_min;
    m_angle_max = x.m_angle_max;
    m_angle_increment = x.m_angle_increment;
    m_time_increment = x.m_time_increment;
    m_scan_time = x.m_scan_time;
    m_range_min = x.m_range_min;
    m_range_max = x.m_range_max;
    m_ranges = x.m_ranges;
    m_intensities = x.m_intensities;
    return *this;
}

LaserScan& LaserScan::operator =(
        LaserScan&& x) noexcept
{

    m_header_value = std::move(x.m_header_value);
    m_angle_min = x.m_angle_min;
    m_angle_max = x.m_angle_max;
    m_angle_increment = x.m_angle_increment;
    m_time_increment = x.m_time_increment;
    m_scan_time = x.m_scan_time;
    m_range_min = x.m_range_min;
    m_range_max = x.m_range_max;
    m_ranges = std::move(x.m_ranges);
    m_intensities = std::move(x.m_intensities);
    return *this;
}

bool LaserScan::operator ==(
        const LaserScan& x) const
{
    return (m_header_value == x.m_header_value &&
           m_angle_min == x.m_angle_min &&
           m_angle_max == x.m_angle_max &&
           m_angle_increment == x.m_angle_increment &&
           m_time_increment == x.m_time_increment &&
           m_scan_time == x.m_scan_time &&
           m_range_min == x.m_range_min &&
           m_range_max == x.m_range_max &&
           m_ranges == x.m_ranges &&
           m_intensities == x.m_intensities);
}

bool LaserScan::operator !=(
        const LaserScan& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member header_value
 * @param _header_value New value to be copied in member header_value
 */
void LaserScan::header_value(
        const Header& _header_value)
{
    m_header_value = _header_value;
}

/*!
 * @brief This function moves the value in member header_value
 * @param _header_value New value to be moved in member header_value
 */
void LaserScan::header_value(
        Header&& _header_value)
{
    m_header_value = std::move(_header_value);
}

/*!
 * @brief This function returns a constant reference to member header_value
 * @return Constant reference to member header_value
 */
const Header& LaserScan::header_value() const
{
    return m_header_value;
}

/*!
 * @brief This function returns a reference to member header_value
 * @return Reference to member header_value
 */
Header& LaserScan::header_value()
{
    return m_header_value;
}


/*!
 * @brief This function sets a value in member angle_min
 * @param _angle_min New value for member angle_min
 */
void LaserScan::angle_min(
        float _angle_min)
{
    m_angle_min = _angle_min;
}

/*!
 * @brief This function returns the value of member angle_min
 * @return Value of member angle_min
 */
float LaserScan::angle_min() const
{
    return m_angle_min;
}

/*!
 * @brief This function returns a reference to member angle_min
 * @return Reference to member angle_min
 */
float& LaserScan::angle_min()
{
    return m_angle_min;
}


/*!
 * @brief This function sets a value in member angle_max
 * @param _angle_max New value for member angle_max
 */
void LaserScan::angle_max(
        float _angle_max)
{
    m_angle_max = _angle_max;
}

/*!
 * @brief This function returns the value of member angle_max
 * @return Value of member angle_max
 */
float LaserScan::angle_max() const
{
    return m_angle_max;
}

/*!
 * @brief This function returns a reference to member angle_max
 * @return Reference to member angle_max
 */
float& LaserScan::angle_max()
{
    return m_angle_max;
}


/*!
 * @brief This function sets a value in member angle_increment
 * @param _angle_increment New value for member angle_increment
 */
void LaserScan::angle_increment(
        float _angle_increment)
{
    m_angle_increment = _angle_increment;
}

/*!
 * @brief This function returns the value of member angle_increment
 * @return Value of member angle_increment
 */
float LaserScan::angle_increment() const
{
    return m_angle_increment;
}

/*!
 * @brief This function returns a reference to member angle_increment
 * @return Reference to member angle_increment
 */
float& LaserScan::angle_increment()
{
    return m_angle_increment;
}


/*!
 * @brief This function sets a value in member time_increment
 * @param _time_increment New value for member time_increment
 */
void LaserScan::time_increment(
        float _time_increment)
{
    m_time_increment = _time_increment;
}

/*!
 * @brief This function returns the value of member time_increment
 * @return Value of member time_increment
 */
float LaserScan::time_increment() const
{
    return m_time_increment;
}

/*!
 * @brief This function returns a reference to member time_increment
 * @return Reference to member time_increment
 */
float& LaserScan::time_increment()
{
    return m_time_increment;
}


/*!
 * @brief This function sets a value in member scan_time
 * @param _scan_time New value for member scan_time
 */
void LaserScan::scan_time(
        float _scan_time)
{
    m_scan_time = _scan_time;
}

/*!
 * @brief This function returns the value of member scan_time
 * @return Value of member scan_time
 */
float LaserScan::scan_time() const
{
    return m_scan_time;
}

/*!
 * @brief This function returns a reference to member scan_time
 * @return Reference to member scan_time
 */
float& LaserScan::scan_time()
{
    return m_scan_time;
}


/*!
 * @brief This function sets a value in member range_min
 * @param _range_min New value for member range_min
 */
void LaserScan::range_min(
        float _range_min)
{
    m_range_min = _range_min;
}

/*!
 * @brief This function returns the value of member range_min
 * @return Value of member range_min
 */
float LaserScan::range_min() const
{
    return m_range_min;
}

/*!
 * @brief This function returns a reference to member range_min
 * @return Reference to member range_min
 */
float& LaserScan::range_min()
{
    return m_range_min;
}


/*!
 * @brief This function sets a value in member range_max
 * @param _range_max New value for member range_max
 */
void LaserScan::range_max(
        float _range_max)
{
    m_range_max = _range_max;
}

/*!
 * @brief This function returns the value of member range_max
 * @return Value of member range_max
 */
float LaserScan::range_max() const
{
    return m_range_max;
}

/*!
 * @brief This function returns a reference to member range_max
 * @return Reference to member range_max
 */
float& LaserScan::range_max()
{
    return m_range_max;
}


/*!
 * @brief This function copies the value in member ranges
 * @param _ranges New value to be copied in member ranges
 */
void LaserScan::ranges(
        const std::vector<float>& _ranges)
{
    m_ranges = _ranges;
}

/*!
 * @brief This function moves the value in member ranges
 * @param _ranges New value to be moved in member ranges
 */
void LaserScan::ranges(
        std::vector<float>&& _ranges)
{
    m_ranges = std::move(_ranges);
}

/*!
 * @brief This function returns a constant reference to member ranges
 * @return Constant reference to member ranges
 */
const std::vector<float>& LaserScan::ranges() const
{
    return m_ranges;
}

/*!
 * @brief This function returns a reference to member ranges
 * @return Reference to member ranges
 */
std::vector<float>& LaserScan::ranges()
{
    return m_ranges;
}


/*!
 * @brief This function copies the value in member intensities
 * @param _intensities New value to be copied in member intensities
 */
void LaserScan::intensities(
        const std::vector<float>& _intensities)
{
    m_intensities = _intensities;
}

/*!
 * @brief This function moves the value in member intensities
 * @param _intensities New value to be moved in member intensities
 */
void LaserScan::intensities(
        std::vector<float>&& _intensities)
{
    m_intensities = std::move(_intensities);
}

/*!
 * @brief This function returns a constant reference to member intensities
 * @return Constant reference to member intensities
 */
const std::vector<float>& LaserScan::intensities() const
{
    return m_intensities;
}

/*!
 * @brief This function returns a reference to member intensities
 * @return Reference to member intensities
 */
std::vector<float>& LaserScan::intensities()
{
    return m_intensities;
}


BasicTypes::BasicTypes()
{

}

BasicTypes::~BasicTypes()
{
}

BasicTypes::BasicTypes(
        const BasicTypes& x)
{
    m_bool_value = x.m_bool_value;
    m_int32_value = x.m_int32_value;
    m_uint32_value = x.m_uint32_value;
    m_int64_value = x.m_int64_value;
    m_uint64_value = x.m_uint64_value;
    m_float_value = x.m_float_value;
    m_double_value = x.m_double_value;
    m_string_value = x.m_string_value;
}

BasicTypes::BasicTypes(
        BasicTypes&& x) noexcept
{
    m_bool_value = x.m_bool_value;
    m_int32_value = x.m_int32_value;
    m_uint32_value = x.m_uint32_value;
    m_int64_value = x.m_int64_value;
    m_uint64_value = x.m_uint64_value;
    m_float_value = x.m_float_value;
    m_double_value = x.m_double_value;
    m_string_value = std::move(x.m_string_value);
}

BasicTypes& BasicTypes::operator =(
        const BasicTypes& x)
{

    m_bool_value = x.m_bool_value;
    m_int32_value = x.m_int32_value;
    m_uint32_value = x.m_uint32_value;
    m_int64_value = x.m_int64_value;
    m_uint64_value = x.m_uint64_value;
    m_float_value = x.m_float_value;
    m_double_value = x.m_double_value;
    m_string_value = x.m_string_value;
    return *this;
}

BasicTypes& BasicTypes::operator =(
        BasicTypes&& x) noexcept
{

    m_bool_value = x.m_bool_value;
    m_int32_value = x.m_int32_value;
    m_uint32_value = x.m_uint32_value;
    m_int64_value = x.m_int64_value;
    m_uint64_value = x.m_uint64_value;
    m_float_value = x.m_float_value;
    m_double_value = x.m_double_value;
    m_string_value = std::move(x.m_string_value);
    return *this;
}

bool BasicTypes::operator ==(
        const BasicTypes& x) const
{
    return (m_bool_value == x.m_bool_value &&
           m_int32_value == x.m_int32_value &&
           m_uint32_value == x.m_uint32_value &&
           m_int64_value == x.m_int64_value &&
           m_uint64_value == x.m_uint64_value &&
           m_float_value == x.m_float_value &&
           m_double_value == x.m_double_value &&
           m_string_value == x.m_string_value);
}

bool BasicTypes::operator !=(
        const BasicTypes& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member bool_value
 * @param _bool_value New value for member bool_value
 */
void BasicTypes::bool_value(
        bool _bool_value)
{
    m_bool_value = _bool_value;
}

/*!
 * @brief This function returns the value of member bool_value
 * @return Value of member bool_value
 */
bool BasicTypes::bool_value() const
{
    return m_bool_value;
}

/*!
 * @brief This function returns a reference to member bool_value
 * @return Reference to member bool_value
 */
bool& BasicTypes::bool_value()
{
    return m_bool_value;
}


/*!
 * @brief This function sets a value in member int32_value
 * @param _int32_value New value for member int32_value
 */
void BasicTypes::int32_value(
        int32_t _int32_value)
{
    m_int32_value = _int32_value;
}

/*!
 * @brief This function returns the value of member int32_value
 * @return Value of member int32_value
 */
int32_t BasicTypes::int32_value() const
{
    return m_int32_value;
}

/*!
 * @brief This function returns a reference to member int32_value
 * @return Reference to member int32_value
 */
int32_t& BasicTypes::int32_value()
{
    return m_int32_value;
}


/*!
 * @brief This function sets a value in member uint32_value
 * @param _uint32_value New value for member uint32_value
 */
void BasicTypes::uint32_value(
        uint32_t _uint32_value)
{
    m_uint32_value = _uint32_value;
}

/*!
 * @brief This function returns the value of member uint32_value
 * @return Value of member uint32_value
 */
uint32_t BasicTypes::uint32_value() const
{
    return m_uint32_value;
}

/*!
 * @brief This function returns a reference to member uint32_value
 * @return Reference to member uint32_value
 */
uint32_t& BasicTypes::uint32_value()
{
    return m_uint32_value;
}


/*!
 * @brief This function sets a value in member int64_value
 * @param _int64_value New value for member int64_value
 */
void BasicTypes::int64_value(
        int64_t _int64_value)
{
    m_int64_value = _int64_value;
}

/*!
 * @brief This function returns the value of member int64_value
 * @return Value of member int64_value
 */
int64_t BasicTypes::int64_value() const
{
    return m_int64_value;
}

/*!
 * @brief This function returns a reference to member int64_value
 * @return Reference to member int64_value
 */
int64_t& BasicTypes::int64_value()
{
    return m_int64_value;
}


/*!
 * @brief This function sets a value in member uint64_value
 * @param _uint64_value New value for member uint64_value
 */
void BasicTypes::uint64_value(
        uint64_t _uint64_value)
{
    m_uint64_value = _uint64_value;
}

/*!
 * @brief This function returns the value of member uint64_value
 * @return Value of member uint64_value
 */
uint64_t BasicTypes::uint64_value() const
{
    return m_uint64_value;
}

/*!
 * @brief This function returns a reference to member uint64_value
 * @return Reference to member uint64_value
 */
uint64_t& BasicTypes::uint64_value()
{
    return m_uint64_value;
}


/*!
 * @brief This function sets a value in member float_value
 * @param _float_value New value for member float_value
 */
void BasicTypes::float_value(
        float _float_value)
{
    m_float_value = _float_value;
}

/*!
 * @brief This function returns the value of member float_value
 * @return Value of member float_value
 */
float BasicTypes::float_value() const
{
    return m_float_value;
}

/*!
 * @brief This function returns a reference to member float_value
 * @return Reference to member float_value
 */
float& BasicTypes::float_value()
{
    return m_float_value;
}


/*!
 * @brief This function sets a value in member double_value
 * @param _double_value New value for member double_value
 */
void BasicTypes::double_value(
        double _double_value)
{
    m_double_value = _double_value;
}

/*!
 * @brief This function returns the value of member double_value
 * @return Value of member double_value
 */
double BasicTypes::double_value() const
{
    return m_double_value;
}

/*!
 * @brief This function returns a reference to member double_value
 * @return Reference to member double_value
 */
double& BasicTypes::double_value()
{
    return m_double_value;
}


/*!
 * @brief This function copies the value in member string_value
 * @param _string_value New value to be copied in member string_value
 */
void BasicTypes::string_value(
        const eprosima::fastcdr::fixed_string<128>& _string_value)
{
    m_string_value = _string_value;
}

/*!
 * @brief This function moves the value in member string_value
 * @param _string_value New value to be moved in member string_value
 */
void BasicTypes::string_value(
        eprosima::fastcdr::fixed_string<128>&& _string_value)
{
    m_string_value = std::move(_string_value);
}

/*!
 * @brief This function returns a constant reference to member string_value
 * @return Constant reference to member string_value
 */
const eprosima::fastcdr::fixed_string<128>& BasicTypes::string_value() const
{
    return m_string_value;
}

/*!
 * @brief This function returns a reference to member string_value
 * @return Reference to member string_value
 */
eprosima::fastcdr::fixed_string<128>& BasicTypes::string_value()
{
    return m_string_value;
}


BigData::BigData()
{

}

BigData::~BigData()
{
}

BigData::BigData(
        const BigData& x)
{
    m_timestamp_value = x.m_timestamp_value;
    m_image_value = x.m_image_value;
    m_point_cloud_value = x.m_point_cloud_value;
    m_index = x.m_index;
}

BigData::BigData(
        BigData&& x) noexcept
{
    m_timestamp_value = std::move(x.m_timestamp_value);
    m_image_value = std::move(x.m_image_value);
    m_point_cloud_value = std::move(x.m_point_cloud_value);
    m_index = x.m_index;
}

BigData& BigData::operator =(
        const BigData& x)
{

    m_timestamp_value = x.m_timestamp_value;
    m_image_value = x.m_image_value;
    m_point_cloud_value = x.m_point_cloud_value;
    m_index = x.m_index;
    return *this;
}

BigData& BigData::operator =(
        BigData&& x) noexcept
{

    m_timestamp_value = std::move(x.m_timestamp_value);
    m_image_value = std::move(x.m_image_value);
    m_point_cloud_value = std::move(x.m_point_cloud_value);
    m_index = x.m_index;
    return *this;
}

bool BigData::operator ==(
        const BigData& x) const
{
    return (m_timestamp_value == x.m_timestamp_value &&
           m_image_value == x.m_image_value &&
           m_point_cloud_value == x.m_point_cloud_value &&
           m_index == x.m_index);
}

bool BigData::operator !=(
        const BigData& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member timestamp_value
 * @param _timestamp_value New value to be copied in member timestamp_value
 */
void BigData::timestamp_value(
        const Timestamp& _timestamp_value)
{
    m_timestamp_value = _timestamp_value;
}

/*!
 * @brief This function moves the value in member timestamp_value
 * @param _timestamp_value New value to be moved in member timestamp_value
 */
void BigData::timestamp_value(
        Timestamp&& _timestamp_value)
{
    m_timestamp_value = std::move(_timestamp_value);
}

/*!
 * @brief This function returns a constant reference to member timestamp_value
 * @return Constant reference to member timestamp_value
 */
const Timestamp& BigData::timestamp_value() const
{
    return m_timestamp_value;
}

/*!
 * @brief This function returns a reference to member timestamp_value
 * @return Reference to member timestamp_value
 */
Timestamp& BigData::timestamp_value()
{
    return m_timestamp_value;
}


/*!
 * @brief This function copies the value in member image_value
 * @param _image_value New value to be copied in member image_value
 */
void BigData::image_value(
        const Image& _image_value)
{
    m_image_value = _image_value;
}

/*!
 * @brief This function moves the value in member image_value
 * @param _image_value New value to be moved in member image_value
 */
void BigData::image_value(
        Image&& _image_value)
{
    m_image_value = std::move(_image_value);
}

/*!
 * @brief This function returns a constant reference to member image_value
 * @return Constant reference to member image_value
 */
const Image& BigData::image_value() const
{
    return m_image_value;
}

/*!
 * @brief This function returns a reference to member image_value
 * @return Reference to member image_value
 */
Image& BigData::image_value()
{
    return m_image_value;
}


/*!
 * @brief This function copies the value in member point_cloud_value
 * @param _point_cloud_value New value to be copied in member point_cloud_value
 */
void BigData::point_cloud_value(
        const PointCloud2& _point_cloud_value)
{
    m_point_cloud_value = _point_cloud_value;
}

/*!
 * @brief This function moves the value in member point_cloud_value
 * @param _point_cloud_value New value to be moved in member point_cloud_value
 */
void BigData::point_cloud_value(
        PointCloud2&& _point_cloud_value)
{
    m_point_cloud_value = std::move(_point_cloud_value);
}

/*!
 * @brief This function returns a constant reference to member point_cloud_value
 * @return Constant reference to member point_cloud_value
 */
const PointCloud2& BigData::point_cloud_value() const
{
    return m_point_cloud_value;
}

/*!
 * @brief This function returns a reference to member point_cloud_value
 * @return Reference to member point_cloud_value
 */
PointCloud2& BigData::point_cloud_value()
{
    return m_point_cloud_value;
}


/*!
 * @brief This function sets a value in member index
 * @param _index New value for member index
 */
void BigData::index(
        uint32_t _index)
{
    m_index = _index;
}

/*!
 * @brief This function returns the value of member index
 * @return Value of member index
 */
uint32_t BigData::index() const
{
    return m_index;
}

/*!
 * @brief This function returns a reference to member index
 * @return Reference to member index
 */
uint32_t& BigData::index()
{
    return m_index;
}

size_t BigData::getCdrSerializedSize(
        const BigData& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Timestamp::getCdrSerializedSize(data.timestamp_value(), current_alignment);
    current_alignment += Image::getCdrSerializedSize(data.image_value(), current_alignment);
    current_alignment += PointCloud2::getCdrSerializedSize(data.point_cloud_value(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t Timestamp::getCdrSerializedSize(
        const Timestamp& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t Image::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += Header::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 256 + 1;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (3840*2160*3 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);




    return current_alignment - initial_alignment;
}

size_t Image::getCdrSerializedSize(
        const Image& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Header::getCdrSerializedSize(data.header_value(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.encoding().size() + 1;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.data().size() > 0)
    {
        current_alignment += (data.data().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    }




    return current_alignment - initial_alignment;
}

size_t PointCloud2::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += Header::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < 256; ++a)
    {
        current_alignment += PointField::getMaxCdrSerializedSize(current_alignment);}

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (4*4*4*1920*1080 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t PointCloud2::getCdrSerializedSize(
        const PointCloud2& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Header::getCdrSerializedSize(data.header_value(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.fields().size(); ++a)
    {
        current_alignment += PointField::getCdrSerializedSize(data.fields().at(a), current_alignment);}

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.data().size() > 0)
    {
        current_alignment += (data.data().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    }



    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t Header::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 256 + 1;


    return current_alignment - initial_alignment;
}

size_t Header::getCdrSerializedSize(
        const Header& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.frame_id().size() + 1;


    return current_alignment - initial_alignment;
}

size_t PointField::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 256 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t PointField::getCdrSerializedSize(
        const PointField& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.name().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}


// Include auxiliary functions like for serializing/deserializing.
#include "datatypesCdrAux.ipp"
