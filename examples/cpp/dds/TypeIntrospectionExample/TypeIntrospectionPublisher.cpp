// Copyright 2022 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @file TypeIntrospectionPublisher.cpp
 *
 */

#include <csignal>
#include <thread>

#include <fastdds/dds/domain/DomainParticipantFactory.hpp>
#include <fastdds/dds/publisher/DataWriter.hpp>
#include <fastdds/dds/publisher/Publisher.hpp>
#include <fastdds/dds/publisher/qos/DataWriterQos.hpp>
#include <fastdds/dds/publisher/qos/PublisherQos.hpp>

#include "TypeIntrospectionPublisher.h"

using namespace eprosima::fastdds::dds;

std::atomic<bool> TypeIntrospectionPublisher::stop_(false);

TypeIntrospectionPublisher::TypeIntrospectionPublisher(
        const std::string& topic_name,
        const uint32_t domain,
        DataTypeKind data_type_kind,
        GeneratorKind generator_kind)
    : data_type_(data_type_factory(data_type_kind, generator_kind))
    , participant_(nullptr)
    , publisher_(nullptr)
    , topic_(nullptr)
    , writer_(nullptr)
{
    DomainParticipantQos pqos;
    pqos.name("TypeIntrospectionExample_Participant_Publisher");

    // CREATE THE PARTICIPANT
    participant_ = DomainParticipantFactory::get_instance()->create_participant(domain, pqos);

    if (participant_ == nullptr)
    {
        throw std::runtime_error("Error creating participant");
    }

    // TODO: add long boring comment
    // TODO: refactor when possible to register type object from XML / dynamic type
    data_type_->register_type_object_representation();

    // REGISTER THE TYPE
    TypeSupport type = data_type_->get_type_support();
    // TODO: add nullptr check
    participant_->register_type(type);

    // CREATE THE PUBLISHER
    publisher_ = participant_->create_publisher(PUBLISHER_QOS_DEFAULT, this);

    if (publisher_ == nullptr)
    {
        throw std::runtime_error("Error creating publisher");
    }

    // CREATE THE TOPIC
    topic_ = participant_->create_topic(topic_name, data_type_->name(), TOPIC_QOS_DEFAULT);

    if (topic_ == nullptr)
    {
        throw std::runtime_error("Error creating topic");
    }

    // CREATE THE WRITER
    DataWriterQos wqos = DATAWRITER_QOS_DEFAULT;
    wqos.reliability().kind = BEST_EFFORT_RELIABILITY_QOS;
    wqos.durability().kind = VOLATILE_DURABILITY_QOS;

    writer_ = publisher_->create_datawriter(topic_, wqos, this);

    if (writer_ == nullptr)
    {
        throw std::runtime_error("Error creating data writer");
    }

    std::cout <<
        "Participant < " << participant_->guid() <<
        " > created in domain < " << participant_->get_domain_id() <<
        " > with writer < " << writer_->guid() <<
        " > with topic < " << topic_name <<
        " > with data type < " << data_type_->name() <<
        " > generated by " << generator_kind <<
        ((writer_->get_type()->m_isGetKeyDefined) ? ". Topic with @key ." : "") <<
        std::endl;
}

bool TypeIntrospectionPublisher::is_stopped()
{
    return stop_;
}

void TypeIntrospectionPublisher::stop()
{
    stop_ = true;
}

TypeIntrospectionPublisher::~TypeIntrospectionPublisher()
{
    if (participant_ != nullptr)
    {
        if (publisher_ != nullptr)
        {
            if (writer_ != nullptr)
            {
                publisher_->delete_datawriter(writer_);
            }
            participant_->delete_publisher(publisher_);
        }
        if (topic_ != nullptr)
        {
            participant_->delete_topic(topic_);
        }
        DomainParticipantFactory::get_instance()->delete_participant(participant_);
    }
}

void TypeIntrospectionPublisher::on_participant_discovery(
        DomainParticipant*,
        eprosima::fastrtps::rtps::ParticipantDiscoveryInfo&& info,
        bool&)
{
    if (info.status == eprosima::fastrtps::rtps::ParticipantDiscoveryInfo::DISCOVERED_PARTICIPANT)
    {
        std::cout << "Participant found with guid: " << info.info.m_guid << std::endl;
    }
}

void TypeIntrospectionPublisher::on_publication_matched(
        DataWriter*,
        const PublicationMatchedStatus& info)
{
    if (info.current_count_change == 1)
    {
        std::cout << "Publisher matched with Reader: " << info.last_subscription_handle << std::endl;
    }
    else if (info.current_count_change == -1)
    {
        std::cout << "Publisher unmatched with Reader: " << info.last_subscription_handle << std::endl;
    }
    else
    {
        std::cout << info.current_count_change
                  << " is not a valid value for PublicationMatchedStatus current count change" << std::endl;
    }
}

void TypeIntrospectionPublisher::runThread(
        uint32_t samples,
        uint32_t sleep)
{
    unsigned int samples_sent = 0;
    while (!is_stopped() && (samples == 0 || samples_sent < samples))
    {
        publish(samples_sent);
        std::this_thread::sleep_for(std::chrono::milliseconds(sleep));
        ++samples_sent;
    }
}

void TypeIntrospectionPublisher::run(
        uint32_t samples,
        uint32_t sleep)
{
    stop_ = false;
    std::thread thread(&TypeIntrospectionPublisher::runThread, this, samples, sleep);

    if (samples == 0)
    {
        std::cout << "Publisher running. Please press CTRL+C to stop the Publisher at any time." << std::endl;
    }
    else
    {
        std::cout << "Publisher running for " << samples <<
            " samples. Please press CTRL+C to stop the Publisher at any time." << std::endl;
    }
    signal(SIGINT, [](int signum)
            {
                std::cout << "SIGINT received, stopping Publisher execution." << std::endl;
                static_cast<void>(signum);
                TypeIntrospectionPublisher::stop();
            });
    thread.join();
}

void TypeIntrospectionPublisher::publish(
        unsigned int msg_index)
{
    if (data_type_->dynamic())
    {
        // Get dynamic data depending on data_type
        auto dyn_data = reinterpret_cast<DynamicData::_ref_type*>(data_type_->get_data(msg_index));

        // Publish data
        writer_->write(dyn_data);

        std::cout << "Message published: \n" << *dyn_data << std::endl;
    }
    else
    {
        // Get data depending on data_type
        auto data = data_type_->get_data(msg_index);

        // Publish data
        writer_->write(data);

        std::cout << "Message published with index: " << msg_index << std::endl;
    }
}
